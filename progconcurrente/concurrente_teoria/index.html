<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <style>
    li a {
        display: block;
        color: white;
        text-align: center;
        padding: 16px;
        text-decoration: none;
    }

    li a:hover {
        background-color: #111111;
    }
    </style>

    <title>Programación concurrente</title>
    <nav>
     <ul  style="text-align: center;
     list-style-type: none;
     margin: 0;
     padding: 0;
     overflow: hidden;
     background-color: #333333;
     float:right;
     text-align: center; ">
       <li style="float: left;"><a href="#filosofia" class="active">Filosofia</a></li>
       <li style="float: left;"><a href="#definición">Definición</a></li>
       <li style="float: left;"><a href="#ventajas">Ventajas</a></li>
       <li style="float: left;"><a href="#desventajas">Desventajas</a></li>
       <li style="float: left;"><a href="#conceptos">Conceptos</a></li>
       <li style="float: left;"><a href="#aplicaciones">Aplicaciones</a></li>
       <li style="float: left;"><a href="#lenguajes">Lenguajes</a></li>
       <li style="float: left;"><a href="#ejemplos">Lenguajes ejemplos</a></li>
       <li style="float: left;"><a href="#referencias">Referencias</a></li>

      </ul>
    </nav>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Programación concurrente</h1>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <!--<h1>
<a id="indice" class="anchor" href="#indice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Índice</h1>

<ol>
<li><a href="#filosofía">Filosofía</a></li>
<li><a href="#definición">Definición</a></li>
<li><a href="#proceso">Proceso</a></li>
<li><a href="#hilo">Hilo</a></li>
<li><a href="#multiprogramación">Multiprogramación</a></li>
<li><a href="#multiproceso">Multiproceso</a></li>
<li><a href="#sincronizacion">Sincronización</a></li>
<li><a href="#notebook">Notebook sincronización</a></li>
<li><a href="#planificacion">Planificación</a></li>
<li><a href="#aplicaciones">Aplicaciones</a></li>
<li><a href="#lenguajes">Lenguajes</a></li>
<li><a href="#presentacion">Presentación</a></li>
<li><a href="#taller">Taller</a></li>
</ol>-->

<div class="text-justify">

<h1>
<a id="filosofía" class="anchor" href="#filosof%C3%ADa" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filosofía</h1>

<p>Es la división de  un problema en subproblemas  que se solucionan de forma individual, para crear un programa o aplicación que no se vea afectada en tiempo real.</p>
<h1>
<a id="definición" class="anchor" href="#definici%C3%B3n" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Definición</h1>

<p>Hace referencia a las técnicas de programación que son utilizadas para expresar la concurrencia entre tareas y solución de los problemas de comunicación y sincronización entre procesos.
  La programación concurrente es la ejecución simultánea de múltiples tareas interactivamente. Estas tareas pueden ser un conjunto de procesos o hilos de ejecución
  creados por un único programa. Las tareas se pueden ejecutar en una sola CPU (multiprogramación), en varios procesadores, o en una red de computadores distribuidos.</p>

<img src="https://s3.postimg.org/435ixtj2r/definicion.jpg" style="margin-left: 30px">
  <div>
    <h1><a id="ventajas" class="anchor" href="#ventajas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ventajas</h1>

    <ul>
      <li>Permite optimizar el uso de recursos en sistemas mono/multiprocesador.</li>
      <li>Fiable administración de los datos en sistemas con gran información</li>
      <li>Mejor aprovechamiento de la CPU</li>
      <li>Permite el desarrollo de aplicaciones que no se vean afectadas en tiempo real</li>
      <li>Permite compartir recursos entre tareas lentas y tareas rápidas para que las tareas lentas no retrasen mucho a las rápidas.</li>
      <li>Velocidad de ejecución.</li>
      <li>Menores tiempos de respuesta.</li>
    </ul>
  </div>
  <div>
    <h1><a id="desventajas" class="anchor" href="#desventajas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Desventajas</h1>
    <ul>
      <li>Consumos de recursos cuando hay excesos de hilos o procesos</li>
      <li >Dificultad de desarrollo.</li>
      <li >Dificultad de verificación.</li>
      <li>En programas con pocas instrucciones en mas lento</li>
      <li >Si se aplica mal puede llevar a resultados erroneos.</li>
    </ul>
  </div>


<h1 id="conceptos">Conceptos</h1>

<h1><a id="proceso" class="anchor" href="#proceso" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Proceso</h1>

<p>Un proceso no solamente es el código de un programa,un proceso tiene un <strong>contador de programa</strong> el cual es un registro del computador que
  indica la dirección de la siguiente instrucción que será ejecutada por el proceso, <strong>Pila de proceso</strong> Esta contiene datos temporales
  tales como: Los parametros de las funciones, direcciones de retorno, variables locales , … , <strong>Sección de datos</strong> la cual contiene datos
  tales como las variables locales, Heap: Cúmulo de memoria que es la memoria que se asigna dinámicamente al proceso n tiempo de ejecución</p>

<div class="center">
<p><img src="https://www.cs.uic.edu/%7Ejbell/CourseNotes/OperatingSystems/images/Chapter3/3_01_Process_Memory.jpg" alt=""></p>
</div>

<p><strong>Note</strong> que un programa por sí sólo no es un proceso, ya que este es una entidad pasiva que contiene una lista de instrucciones almacenadas en disco ( archivo ejecutable),  mientras que un proceso es una entidad activa, el cual cumple todas las características descritas anteriormente.</p>

<p><strong>Estados del proceso</strong>
Cuando un proceso es ejecutado este cambia de estados, los estados que todo proceso tiene por lo general son:</p>

<ul>
<li><p><strong>Nuevo</strong>:        El proceso se está creando.</p></li>
<li><p><strong>Corriendo</strong>:        Se están ejecutando las instrucciones.</p></li>
<li><p><strong>Espera</strong>:        El proceso está esperando que algún evento ocurra.</p></li>
<li><p><strong>Preparado</strong>:    El proceso está esperando ser asignado al procesador.</p></li>
<li><p><strong>Terminado</strong>:    El proceso a terminado la ejecución. </p></li>
</ul>

<img src="https://www.cs.uic.edu/%7Ejbell/CourseNotes/OperatingSystems/images/Chapter3/3_02_ProcessState.jpg" alt=""></p></li>

<p><strong>PCB ( Bloque de control de proceso )</strong>
Cada proceso se representa en el sistema operativo mediante el PCB, entre los elementos de información que este contiene se encuentran:</p>

<ul>
<li><p><strong>Estado del proceso</strong>:  New, ready, running, waiting, halted, ...</p></li>
<li><p><strong>Contador del programa</strong>: </p></li>
<li><p><strong>Registros de la CPU</strong>:    Estos varían en cuanto a número y tipo dependiendo  de la arquitectura del procesador</p></li>
<li><p><strong>Información de planificación de la CPU</strong>: Parametros de planificación como prioridad de procesos, punteros  a las colas de planificación ...</p></li>
<li><p><strong>Información de gestión de memoria</strong>: Tablas de paginas , tablas de segmentos, dependiendo los mecanismos de gestión del S.O</p></li>
</ul>

<div class="center">
<p><img src="https://www.cs.uic.edu/%7Ejbell/CourseNotes/OperatingSystems/images/Chapter3/3_03_PCB.jpg" alt=""></p>
</div>
<h1>
<a id="multiprogramación" class="anchor" href="#multiprogramaci%C3%B3n" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multiprogramación</h1>

<p>Es una técnica de multiplexación que permite de múltiples procesos en un único procesador.
Es importante resaltar que los procesos nunca corren en paralelo en el procesador, ya que en cada instante de tiempo solo se ejecuta un proceso en el procesador.</p>

<h1>
<a id="multiproceso" class="anchor" href="#multiproceso" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multiproceso</h1>

<p>Es una técnica en la cual se hace uso de dos o más procesadores en una computadora para ejecutar uno o varios procesos.</p>

<h1>
<a id="procesamiento-distribuido" class="anchor" href="#procesamiento-distribuido" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Procesamiento distribuido</h1>

<p>Es cuando uno o varios procesos son ejecutados en una o más computadores</p>

<h2><a id="calendarizacion" class="anchor" href="#proceso" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Calendarización De Procesos</h2>

<p>Estrategia de los sistemas operativos con la que se es posible compartir la CPU entre los diferentes procesos alojados en memoria.
La calendarización es un manejo de colas con el objetivo de maximizar el uso de recursos y minimizar retardos.</p>

<img src="https://s9.postimg.org/je2q58qmn/calendarizacion.jpg" style="margin-left: 30px">
  <h2>Tipos de Calendarización</h2>

  <h3>Calendarización a corto plazo</h3>
  <ul>
  <li>Determina cuáles programas son admitidos al sistema para la ejecución.</li>
  <li>El objetivo principal es mantener una mezcla balanceada de tareas, como los límites de entrada/salida y de procesador.</li>
  <li>Controla el nivel de multiprogramación.</li>
  </ul>

  <h3>Calendarización a mediano plazo</h3>
  También conocido como CPU scheduler o dispatcher. Su principal objetivo es incrementar el rendimiento del sistema acorde a un criterio definido.
  <br><b>Dispatch latency:</b>  Tiempo que toma entre parar un proceso y empezar otro.

  <h3>Calendarización a largo plazo</h3>
  <ul>
  <li>Hace parte del swapping del sistema.</li>
  <li>Agrega y remueve procesos de memoria.</li>
  <li>Reduce el nivel de multiprogramación del sistema.</li>
  </ul>

  <h2>Cambios de contexto</h2>

  Mecanismo para almacenar y restaurar el estado de un proceso.

  <ul>
  <li>Registers</li>
  <li>Stack pointer</li>
  <li>Program counter</li>
  </ul>

  <div class="center">
  <p><img src="https://www.tutorialspoint.com/operating_system/images/context_switch.jpg" alt="Cambio de contexto"></p>
  </div>

  <h2>Criterios de Calendarización</h2>

  <ul>
  <li><strong>Utilización de CPU:</strong> mantener el CPU lo más ocupado posible</li>
  <li><strong>Throughput:</strong> Procesos completados por unidad de tiempo</li>
  <li><strong>Tiempo de vuelta:</strong> tiempo en completar un proceso en específico</li>
  <li><strong>Tiempo de espera:</strong> tiempo en el que un proceso ha estado en la cola de ready</li>
  <li><strong>Tiempo de respuesta:</strong> tiempo que toma desde la creación del proceso hasta su primera respuesta</li>
  </ul>

  <h2>Algoritmos de Calendarización</h2>

  <div class="text-justify">
  <p>El principal objetivo de los algoritmos de calendarización es asignar tiempos de ejecución a los procesos del sistema para optimizar uno o más aspectos del mismo.</p>
  </div>
  <ul>
  <li><strong>First-Come, First-Served (FCFS)</strong></li>
  <p>Algoritmo simple de calendarización, en el que asigna el procesador según el orden de llegada a la cola de ready y lo ejecuta hasta el final,
    como ventajas tienen un buen throughput y tiempo de vuelta, como desventajas malos tiempos de respuesta y de espera, en cuanto a utilización de CPU
  tiene la ventaja de que hace pocos cambios de contexto, mas se desaprovecha el CPU cuando los procesos tienen que esperar a entradas y/o salidas.</p>
  <p><img src="https://s18.postimg.org/cvdn2v4ft/fcfs1.jpg" style="margin-left: 30px"></p>
  <p><img src="https://s7.postimg.org/5ng6kqtx7/fcfs.jpg" style="margin-left: 30px"></p>
  <li><strong>Shortest-Job-First (SJF)</strong></li>
  <p>con SJF se ejecuta primero el proceso con menor tiempo de ejecución que se encuentre en la cola de ready, a comparación de FCFS tiene
  mejor tiempo de respuesta, mejor throughput, menores tiempos de espera, en cuanto a uso del CPU se comporta igual a FCFS, como desventaja tiene
  la dificultad de predecir el tiempo de ejecución de un proceso. </p>
  <p><img src="https://s24.postimg.org/mjnlamwp1/sjf1.jpg" style="margin-left: 30px"></p>
  <p><img src="https://s12.postimg.org/guh11mzi5/sjf.jpg" style="margin-left: 30px"></p>
  <li><strong>Priority Scheduling</strong></li>
  <p>Introduce una necesidad en el que unos procesos deben tener prioridad sobre otros, para ello asocia un numero indicando el nivel de prioridad a cada proceso
  cuando están en la cola de ready selecciona el de mayor prioridad, como desventaja los procesos con baja prioridad podrían sufrir de starvation
  tardando mucho o nunca saliendo de la cola de ready, esto se soluciona utilizando una técnica en la que a medida que va pasando el tiempo se incrementa
  la prioridad de un proceso en la cola, por lo que aquellos que lleven mucho tiempo en esta irán aumentando su prioridad. Dependiendo de las prioridades
  que se le asignen a cada proceso puede tener buenos o malos tiempos. Hay que tener en cuenta que si ningún otro proceso está en la cola de ready ejecutara
  el único que haya en la cola, más en el momento que llegue un proceso con mayor prioridad se sacara de ejecución el de menor y el CPU lo ocupara el que acaba
  de llegar con mayor prioridad, esto se evidencia en el ejemplo a continuación:</p>
  <p><img src="https://s28.postimg.org/o9zd19hod/priority.jpg" style="margin-left: 30px"></p>
  <p><img src="https://s14.postimg.org/k1wtmwtq9/priority2.jpg" style="margin-left: 30px"></p>
  <li><strong>Round Robin (RR)</strong></li>
  <p>Se asigna un tiempo de CPU (time quantum) para todos los procesos, estos se ejecutarán durante ese tiempo según el orden de llegada, en cuanto completan el tiempo
  asignado se sacan de ejecución y se regresan a la cola de ready, este procedimiento se repite hasta que el proceso complete toda su ejecución. Como
  ventaja tiene bajos tiempos de espera y de respuesta, peor tiempo de vuelta y throughput mas bajo que SJF, el uso del CPU baja por el mayor numero
  de cambios de contexto que debe hacer, por lo que es importante escoger un buen time quantum, si se escoge un tiempo muy corto habrá muchos cambios de contexto
  y los procesos tardaran mucho más en terminar, si se escoge muy grande se perderían las ventajas del algoritmo, se suele usar tiempos de 10ms a 100ms, también
  hay que tener en cuenta que para que sea optimo este tiempo debe ser mayor al que tarda el procesador en hacer un cambio de contexto. </p>
  <p><img src="https://s14.postimg.org/b4jih3wzl/image.jpg" style="margin-left: 30px"></p>
  <p><img src="https://s23.postimg.org/smstmzwnv/rr2.jpg" style="margin-left: 30px"></p>
  <li><strong>Multiple-Level Queues</strong></li>
  <p>la cola de ready se parte en varias colas que determinan la prioridad de los procesos, cada cola implementa su propio algoritmo de calendarización y
  adicionalmente tambien se hace calendarización entre las colas</p>
  <p><img src="https://s11.postimg.org/ac3tmerfn/multiqueue.jpg" style="margin-left: 30px"></p>
  </ul>

<h1>
<a id="hilo" class="anchor" href="#hilo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hilo</h1>

<p>Se puede definir como una unidad básica de utilización del CPU. Cada hilo tiene:
Id de hilo,  Contador de programa,  Registros, Pila.
Los hilos que pertenecen a un mismo proceso comparten:
Sección de código, sección de datos, entre otros recursos del sistema.</p>
<p><img src="https://s3.postimg.org/z6m2055rn/procesoshilos.jpg" style="margin-left: 30px"></p>


<h1>
<a id="programacion-paralela-y-concurrente" class="anchor" href="#programacion-paralela-y-concurrente" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Programacion Paralela y Concurrente</h1>

<h2>
<a id="relacion" class="anchor" href="#relacion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Relación</h2>

<p>Multiples procesos pueden ser ejecutados al mismo tiempo. En otra palabras, la programacion concurrente se comporta igual que la paralela cuando tenemos un sistema multiprocesador en el cual cada unidad de procesamiento ejecuta un proceso o hilo. En la imagen inferior podemos ver que el la unidad de procesamiento 2 y 3 se comportan igual.</p>

<p><img src="http://s32.postimg.org/s503ixn05/paralellismo.jpg" alt=""></p>

<p>Hay que aclarar la concurrencia no solo es paralelismo, ya que, cuando hay mas procesos o hilos el scheduler del sistema operativo interviene y divide la ejecucion de los procesos, <strong>caracteristica que la programacion paralela NO tiene</strong> cada proceso tiene que ser ejecutado exclusivamente en una unidad de procesamiento. En la parte inferior podemos apreciar mejor la diferencia.</p>

<p><img src="http://joearms.github.io/images/con_and_par.jpg" alt=""></p>

<h1>
<a id="sincronizacion" class="anchor" href="#sincronizacion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sincronizacion</h1>

<p>Cuando tenemos varios procesos o hilos en la ejecucion, en muchos casos no queremos que estos se ejecuten al mismo tiempo. El mecanismo que controla el orden de ejecucion de determinadas tareas lo llamamos <strong>SINCRONIZACION</strong>.</p>

<p><em><strong>¿Por qué el algunos casos no queremos que los hilos se ejecuten al mismo tiempo?</strong></em></p>

<div class="center">
<p><img src="http://www.blogdepsicologia.com/wp-content/uploads/2015/06/ansiedad-2.jpg" alt=""></p>
</div>
<p><em><strong>porque se dan condiciones de carrera.</strong></em></p>
<h2>
<a id="condicion de carrera" class="anchor" href="#condicion de carrera" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Condición de carrera</h2>

<p>Se da cuando uno o mas hilos ejecutan secciones que otro hilo podría usar al mismo tiempo, y en estas modifica variables que podrían afectar la ejecución del resto de hilos </p>

<h2><a id="problema contador" class="anchor" href="#problema contador" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Problema simple con un contador</h2>
<p>si tenemos dos hilos, y estos tratan de ejecutar cada uno un comando de contador++(hilo azul) y el otro el de contador--(hilo rojo), al mismo tiempo
si el contador está en 5 se esperaría que al hacerle ++ y -- este quede igual, más en el ejemplo se ilustra que si los hilos no se sincronizan esto
no sucede así:</p>
<p>las instrucciones de contador++ y contador-- se pueden desglosar así:</p>
<p><img src="https://s15.postimg.org/b3tcymfwr/problema_contador.jpg" alt=""></p>
<p>Posible ejecución:</p>
<p><img src="https://s4.postimg.org/antlcbbr1/problema_contador_ejecucion.jpg" alt=""></p>

<h2>
<a id="problema-del-lector---escritor" class="anchor" href="#problema-del-lector---escritor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Problema del Lector - Escritor</h2>

<p>Cuando tenemos varios lectores y escritores, por ejemplo, en un base de datos, muchos procesos van a intentar leer o escribir al mismo tiempo, lo cual no podemos permitir, ya que, nuestra informacion se podria perder, duplicar, corromper entre otros. Solo es posible que un proceso leo o escriba y que los demas esperen su turno. </p>

<h2>
<a id="problema-de-los-filosofos-que-cenan" class="anchor" href="#problema-de-los-filosofos-que-cenan" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Problema de los filosofos que cenan</h2>

<div class="center">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/200px-An_illustration_of_the_dining_philosophers_problem.png" alt=""></p>
</div>

<p>Cada filósofo pueda tomar los tenedores que están a su izquierda o derecha, para poder comer el filósofo de tener los dos tenedores. Si cualquier filósofo toma los dos tenedores entonces los que están al lado queda en espera. Hay un tenedor y los dos filósofos compiten por tomarlo y uno queda sin tenedores. </p>

<p>Si todos los filósofos toman el tenedor que está a su derecha entonces todos se quedaran esperando infinitamente. Nadie va a ceder su tenedor porque todos están en la misma situación.</p>

<p>Como podemos hacer para que los filósofos no se mueran de hambre?. Interesante no, el problema en sí tiene muchas soluciones pero solo vamos a enunciar una: Un filosofo toma los dos tenedores y se los demas hacen una cola alrededor de la mesa para saber cual es el siguiente hasta que todos acaban.</p>

<h2>
<a id="problema-productor-consumidor" class="anchor" href="#problema-productor-consumidor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Problema del Productor - Consumidor</h2>

<p>Existen uno o más productores y uno o más consumidores, todos almacenan y extraen productos de una misma bodega. El productor produce productos cada vez que puede, y el consumidor los consume cada vez que lo necesita.
</p>
<p>
Problema:<br>
¿Cómo coordinamos a los productores y consumidores, para que los productores no produzcan más ítems de los que se pueden almacenar en el momento, y los consumidores no adquieran más ítems de los que hay disponibles?. </p>
<br>
<p>
Solucion:<br>
Desde el punto de vista de la programación concurrente la solución a este problema se plantea a través de herramientas de sincronización. La primera solución y la más sencilla es implementar bodegas que sean excluyentes, es decir si un consumidor o productor se encuentra haciendo de la bodega, nadie más pueda hacerlo, indicando este estado con cualquier tipo de señal o aviso, implementado a través de semáforos binarios, cuyo concepto también es explicado en esta página.</p>
<p>
La anterior solución aunque es funcional y completamente viable, no es del todo acertada, luego de profundizar en el enfoque de la programación concurrente se destaca que tiene fallos muy probables, debido a que puedo agregar más actores a este ambiente, y si solo uno de estos no aplica la metodología del semáforo de manera acertada la información se corromperá, además de contener un bloque de código igual en todos los consumidores y productores. Para solucionar esto se plantea una solución a través de un monitor el cual se encargará de revisar los procesos de compra y producción, eliminando así el código clonado, además de organizar los procesos desde el objeto de las bodegas en sí.</p>

<h2>Sección Critica</h2>
<p><img src="http://ecoosfera.com/wp-content/imagenes/interseccion.gif" alt=""></p>

<p>Para solucionar estos inconvenientes hay que identificar las secciones de código en las que se pueden dar condiciones de carrera y permitir que solo un hilo
entre a estas secciones a la vez. Podríamos pensar en un cruce de autos como una sección critica, en la que los autos que vayan en otro sentido no podrán
ingresar al cruce hasta que los carros del carril que tiene el semáforo en verde (tienen permiso de entrar a la sección critica) terminen de pasar.</p>

<h2>Métodos de sincronización y comunicación</h2>
<p>Existen diversas formas en las que podemos sincronizar y comunicar los hilos, entre ellas tenemos:</p>
<ul>
<li><strong>Semáforos:</strong> Un hilo adquiere permiso al entrar a la sección crítica, al finalizar la respectiva sección critica libera el permiso.</li>
<li><strong>Mutex:</strong> Semáforo de tamaño 1. </li>
<li><strong>Monitores:</strong> cada hilo tiene un turno, todos los hilos deben esperar mientras el hilo que tenga el turno esté presente en la sección crítica.</li>
<li><strong>Mensajes:</strong> Los hilos se comunican por medio de mensajes, avisandole a los otros hilos cuando puede hacer sus respectivas ejecuciones sobre la sección crítica.</li>
</ul>
<p>como ejemplo supongamos que en 2 o más bancos se hacen transacciones sobre una misma cuenta,
si en uno de los bancos (un hilo) cambia el valor de la cuenta mientras en otro banco se realiza una transacción sobre la misma
se daría una condición de carrera, para evitar esto usaremos los múltiples métodos de sincronización:</p>
<p><strong>Ejemplo en java de semaforos: </strong></p>
<pre class="prettyprint">
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Scanner;
import java.util.concurrent.Semaphore;
import java.util.logging.Level;
import java.util.logging.Logger;

//la clase extiende de thread
public class Banco2 extends Thread{
    static int cuenta=0;
    int Operaciones;
    int [] transaccion;
    final Semaphore available = new Semaphore(1, true);
    boolean[] used = new boolean[1];

    public Banco2(int Operaciones, int[] transaccion) {
        this.Operaciones = Operaciones;
        this.transaccion = transaccion;
    }




    //se sobreescribe el metodo run, que es el que correra al momento de iniciar los hilos
    @Override
    public void run()  {
        try {
        //el hilo adquiere permiso para entrar a la seccion critica
        available.acquire();
        for(int i=0;i< this.Operaciones;i++){
           int temp=cuenta;
                temp=temp+this.transaccion[i];
                cuenta=temp;
            }
        //el hilo libera el permiso
        available.release();
         } catch (InterruptedException ex) {
                Logger.getLogger(Banco2.class.getName()).log(Level.SEVERE, null, ex);
        }


    }
    public static void main(String[] args) throws InterruptedException {
         Scanner sc;

        try {
            //se recibe un archivo con operaciones de entrada y se guardan en arreglos
            sc = new Scanner(new FileReader("C:/archivo3.txt"));
            int A=sc.nextInt();
            int B=sc.nextInt();
            int [] arregloA= new int[A];
            int [] arregloB= new int[B];
            for (int i=0;i< A;i++){
                arregloA[i]=sc.nextInt();
            }
            for (int i=0;i< B;i++){
                arregloB[i]=sc.nextInt();
            }
            Banco2 a=new Banco2(A,arregloA);
            Banco2 b=new Banco2(B,arregloB);
            //se crean los hilos asociados a cada instancia de la clase
            a.start();
            b.start();
            //join de los hilos con el hilo principal de ejecucion
            a.join();
            b.join();
            System.out.println(cuenta);
    }catch (FileNotFoundException ex) {
            Logger.getLogger(Banco2.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

}
</pre>

<p><strong>Ejemplo en java de monitores: </strong></p>
<pre class="prettyprint">
  import java.io.FileNotFoundException;
  import java.io.FileReader;
  import java.util.Scanner;
  import java.util.logging.Level;
  import java.util.logging.Logger;

  //igual extiende de la clase hilo
  public class Banco3 extends Thread{
      static int cuenta=0;
      int Operaciones;
      int [] transaccion;
      //usamos turnos para saber cual hilo debe ejecutarse
      static boolean turno = true;

      public Banco3(int Operaciones, int[] transaccion) {
          this.Operaciones = Operaciones;
          this.transaccion = transaccion;
      }

      public synchronized void Operar() throws InterruptedException{
          //mientras el turno no este disponible el hilo espera
          while(!turno) {
              wait();
          }
          //si el turno esta disponible, se toma, poniendolo como false para el resto
          //de hilos
          turno=false;
          for(int i=0;i< this.Operaciones;i++){
                  int temp=cuenta;
                  temp=temp+this.transaccion[i];
                  cuenta=temp;

          }
          //el turno se libera y se le notifica a los hilos que estaban en espera
          turno=true;
          notifyAll();
      }
      @Override
      public void run()  {
          try {
              Operar();
          } catch (InterruptedException ex) {
              Logger.getLogger(Banco3.class.getName()).log(Level.SEVERE, null, ex);
          }
      }
      public static void main(String[] args) throws InterruptedException {
           Scanner sc;

          try {
              sc = new Scanner(new FileReader("C:/archivo3.txt"));
              int A=sc.nextInt();
              int B=sc.nextInt();
              int [] arregloA= new int[A];
              int [] arregloB= new int[B];
              for (int i=0;i< A;i++){
                  arregloA[i]=sc.nextInt();
              }
              for (int i=0;i< B;i++){
                  arregloB[i]=sc.nextInt();
              }
              Banco3 a=new Banco3(A,arregloA);
              Banco3 b=new Banco3(B,arregloB);
              a.start();
              b.start();
              a.join();
              b.join();
              System.out.println(cuenta);
      }catch (FileNotFoundException ex) {
              Logger.getLogger(Banco3.class.getName()).log(Level.SEVERE, null, ex);
          }
      }

  }
</pre>

<p><strong>Ejemplo en java de mensajes (es necesario usar el toolkit de akka): </strong></p>
<pre class="prettyprint">
  import akka.actor.UntypedActor;
  //extiende de un actor de la toolkit de akka
public class BankActor extends UntypedActor{
    static public int cuenta=0;
    //los actores se comunican entre si, se sobreescribe el metodo
    //de onReceive que se ejecuta cuando un hilo recibe mensajes de otro hilo
    @Override
    public void onReceive(Object message) throws Exception {
        if(message instanceof Integer) {
            int a= new Integer((int) message);
            int temp=cuenta;
            temp=temp+a;
            cuenta=temp;
        }else{
            //se tiene en cuenta si el actor no puede comprender el mensaje que se le envio
            unhandled(message);
        }
    }
}


import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import java.util.Scanner;


public class Akka {

    public static void main(String[] args) {
        //se instancia un sistema de comunicacion entre los actores
        ActorSystem system=ActorSystem.create("Transacciones");
        //se instancian los dos actores
        ActorRef bankActor = system.actorOf(new Props(BankActor.class), "Transaccion1");
        ActorRef bankActor2 = system.actorOf(new Props(BankActor.class), "Transaccion2");
        Scanner sc2 = new Scanner(System.in);
        int A = sc2.nextInt();
        int B = sc2.nextInt();
        int [] arregloA= new int[A];
        int [] arregloB= new int[B];
        int mayor=0;
        if (A< B){mayor=B;}
        else {mayor=A;}
        for (int i=0;i< mayor;i++){
            //los actores se comunican entre si las transacciones que van haciendo
            if (i< A){
                arregloA[i]=sc2.nextInt();
                bankActor.tell(arregloA[i],null);
            }
            if (i< B){
                arregloB[i]=sc2.nextInt();
            bankActor2.tell(arregloB[i],null);
            }
        }
        system.shutdown(); //cierra la comunicacion
        system.awaitTermination();//join con el hilo principal
        System.out.println(BankActor.cuenta);
    }
}
</pre>

<ul><li>Solucion del problema Productor - Consumidor</li></ul>
<p>- Con semaforos</p>
<pre class="prettyprint">
semaphore fillCount = 0;
semaphore emptyCount = BUFFER_SIZE; 

procedure producer() {
  while (true) {
    item = produceItem();
    down(emptyCount);
    putItemIntoBuffer(item);
    up(fillCount);
  }
}

procedure consumer() {
  while (true) {
    down(fillCount);
    item = removeItemFromBuffer();
    up(emptyCount);
    consumeItem(item);
  }
}
</pre>

<p>- Con monitores</p>
<pre class="prettyprint">
monitor ProducerConsumer {
  int itemCount;
  condition full;
  condition empty;

  procedure add(item) {
    while (itemCount == BUFFER_SIZE) {
        wait(full);
    }
    putItemIntoBuffer(item);
    itemCount = itemCount + 1;
    if (itemCount == 1) {
        notify(empty);
    }
  }

  rocedure remove() {
      while (itemCount == 0) {
          wait(empty);
      }

      item = removeItemFromBuffer();
      itemCount = itemCount - 1;

      if (itemCount == BUFFER_SIZE - 1) {
          notify(full);
      }
      return item;
  }
}

procedure producer() {
    while (true) {
        item = produceItem()
        ProducerConsumer.add(item)
    }
}

procedure consumer() {
    while (true) {
        item = ProducerConsumer.remove()
        consumeItem(item)
    }
}



</pre>

<p>Los métodos de sincronización y comunicación se explican de mejor forma mediante el uso del notebook, pues los temas se explican con el uso python y C++.</p>

<a id="notebook"></a>
<h3><a href="http://nbviewer.jupyter.org/url/ferestrepoca.github.io/paradigmas-de-programacion/progconcurrente/concurrente_teoria/notebook/ProgConcurrente.ipynb">Notebook</a></h3>

<h1>
<a id="aplicaciones" class="anchor" href="#aplicaciones" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Aplicaciones</h1>

<ol>
<li>Servidores Web</li>
<li>Sistema multimedia</li>
<li>Calculo numerico</li>
<li>Interaccion por GUI</li>
<li>Sistemas gestores de bases de datos</li>
<li>Sistemas Operativos</li>
<li>Sistemas de control</li>
<li>Simulación</li>
<li>videojuegos</li>





</ol>

<h1>
<a id="lenguajes" class="anchor" href="#lenguajes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lenguajes</h1>

<ul><li><strong>Elixir</strong></li></ul>
<center><img src="images/elixir.png" width="150px" height="150px"></center>
<br>
Elixir es lenguaje de programación de propósito general, concurrente; este lenguaje es funcional. Además está construido sobre la MV de Erlang y aprovecha esto para construir sistemas distribuidos y tolerantes a fallos con baja latencia.

<ul><li><strong>Rust</strong></li></ul>
<center><img src="images/rust.png" width="150px" height="150px"></center>
Rust es un lenguaje de programación compilado, de propósito general y multiparadigma desarrollado por Mozilla y ha sido diseñado para ser ‘un lenguaje seguro, concurrente y práctico’. Rust se enfoca principalmente en seguridad, velocidad y concurrencia.

<ul><li><strong>Erlang</strong></li></ul>
<center><img src="images/erlang.png" width="150px" height="150px"></center>
Erlang es un lenguaje de programación funcional de alto nivel, diseñado para escribir aplicaciones concurrentes y distribuidas de funcionamiento ininterrumpido. Erlang usa procesos concurrentes para estructurar la aplicación. Estos procesos no comparten memoria y se comunican de forma asincrónica mediante el paso de mensajes. 

<ul><li><strong>GO</strong></li></ul>
<center><img src="images/go.png" width="150px" height="150px"></center>
GO Es un lenguaje de programación compilado, concurrente, imperativo, estructurado, no orientado a objetos con recolector de basura, soportado en diferentes tipos de sistemas. La concurrencia en Go es diferente a los criterios de programación basados en bloqueos como pthreads.

<ul><li><strong>Haskell</strong></li></ul>
<center><img src="images/haskell.png" width="150px" height="150px"></center>
Haskell es un lenguaje polimórficamente tipificado, perezoso, puramente funcional, muy diferente a la mayoría de los otros lenguajes de programación.

<ul><li><strong>Crystal</strong></li></ul>
<center><img src="images/crystal.png" width="150px" height="150px"></center>
Haskell es un lenguaje polimórficamente tipificado, perezoso, puramente funcional, muy diferente a la mayoría de los otros lenguajes de programación.


<h1>
<a id="ejemplos" class="anchor" href="#ejemplos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lenguajes ejemplos</h1>

<ul>
<li>Ejemplo en <strong>python</strong>: Este es un pequeño ejemplo con el fin de ilustrar como podemos lanzar un hilo en python</li>
</ul>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> threading <span class="pl-k">import</span> Thread
<span class="pl-k">import</span> time

<span class="pl-k">def</span> <span class="pl-en">say_hello</span>(<span class="pl-smi">name</span>):
    <span class="pl-c1">print</span> (name, <span class="pl-s"><span class="pl-pds">"</span>Hola<span class="pl-pds">"</span></span>)

t <span class="pl-k">=</span> Thread(<span class="pl-v">target</span><span class="pl-k">=</span>say_hello, <span class="pl-v">args</span><span class="pl-k">=</span>(<span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>,))
t.start()
t.join()</pre></div>

<p><strong>Ejecucion:</strong> python archivo.py</p>

<blockquote>
<p>('world', 'Hola')</p>
</blockquote>

<ul>
<li>Ejemplo en <em>GO</em>: En este ejemplo podemos visualizar que los hilos no se ejecutan en el orden ascedente si no esto lo decide el scheduler del sistema operativo</li>
</ul>

<div class="highlight highlight-source-go"><pre><span class="pl-k">package</span> main

<span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>fmt<span class="pl-pds">"</span></span>
    <span class="pl-s"><span class="pl-pds">"</span>time<span class="pl-pds">"</span></span>
)

<span class="pl-k">const</span> <span class="pl-v">FINAL</span> = <span class="pl-c1">100</span> * time.<span class="pl-smi">Millisecond</span>

<span class="pl-k">func</span> <span class="pl-en">saluda</span>(<span class="pl-v">i</span> <span class="pl-v">int</span>) {
    time.<span class="pl-c1">Sleep</span>(<span class="pl-c1">10</span> * time.<span class="pl-c1">Duration</span>(i%<span class="pl-c1">5</span>) * time.<span class="pl-smi">Millisecond</span> )
    fmt.<span class="pl-c1">Println</span>(<span class="pl-s"><span class="pl-pds">"</span>Hola a todos<span class="pl-pds">"</span></span>, i)
}

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
    <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">:=</span> <span class="pl-c1">1</span>; i &lt;= <span class="pl-c1">6</span>; i++ {
        <span class="pl-c">// Lanzamos nuestro hilo solo anteponiendo la palabra go a la funcion</span>
        <span class="pl-k">go</span> <span class="pl-c1">saluda</span>(i)
    }
    time.<span class="pl-c1">Sleep</span>(FINAL)
}</pre></div>

<p><strong>Ejecucion:</strong> go run archivo.go</p>

<blockquote>
<p>Hola a todos 5</p>

<p>Hola a todos 6</p>

<p>Hola a todos 1</p>

<p>Hola a todos 2</p>

<p>Hola a todos 3</p>

<p>Hola a todos 4</p>
</blockquote>

<ul>
<li>Ejemplos semaforo en <strong>C</strong>: El siguiente codigo fuente solo sirve sistemas operativos basado en unix.</li>
</ul>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdlib.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>pthread.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>unistd.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>sys/types.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>fcntl.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>sys/stat.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>semaphore.h<span class="pl-pds">&gt;</span></span>

#<span class="pl-k">define</span> <span class="pl-en">NUMHILOS</span> <span class="pl-c1">5</span>

<span class="pl-c1">sem_t</span> *semaforo;
<span class="pl-k">int</span> error, i, parametro, a;
<span class="pl-k">char</span> t;
<span class="pl-k">void</span> *z;

<span class="pl-k">void</span> *<span class="pl-en">fun</span>(<span class="pl-k">void</span> *ap )
{
    <span class="pl-c1">sem_t</span> *sem = ap;
    <span class="pl-k">char</span> t;
    <span class="pl-c1">sem_wait</span>( sem ); <span class="pl-c">// Bloqueamos seccion critica</span>
    <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span> Hilo ENTRO a seccion critica<span class="pl-pds">"</span></span> );
    <span class="pl-c1">fflush</span>( stdout );
    <span class="pl-c1">sleep</span>( <span class="pl-c1">1</span> );
    <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span> Hilo SALIO a seccion critica<span class="pl-cce">\n\n</span><span class="pl-pds">"</span></span> );
    <span class="pl-c1">fflush</span>( stdout );
    <span class="pl-c1">sem_post</span>( sem ); <span class="pl-c">// Desbloqueamos seccion critica</span>
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    <span class="pl-c">// Creamos nuestro semaforo</span>
    semaforo = <span class="pl-c1">sem_open</span>( <span class="pl-s"><span class="pl-pds">"</span>sema<span class="pl-pds">"</span></span>, O_CREAT, <span class="pl-c1">0666</span>, <span class="pl-c1">1</span> );

    <span class="pl-c">// Declaramos el descritor de los hilos</span>
    <span class="pl-c1">pthread_t</span> hilos[NUMHILOS];

    <span class="pl-c">// Creamos nuestros hilos</span>
    <span class="pl-k">for</span>( i = <span class="pl-c1">0</span>; i &lt; NUMHILOS; i++ )
        <span class="pl-c1">pthread_create</span>( &amp;hilos[i], <span class="pl-c1">NULL</span>, (<span class="pl-k">void</span> *)fun, semaforo );

    <span class="pl-c">// Esperamos a que nuestro hilos de ejecutan antes de terminar el programa</span>
    <span class="pl-k">for</span>( i = <span class="pl-c1">0</span>; i &lt; NUMHILOS; i++ )
        <span class="pl-c1">pthread_join</span>( hilos[i], (<span class="pl-k">void</span> *)&amp;z );

    <span class="pl-c">// Destruimos nuestro semaforo</span>
    <span class="pl-c1">sem_unlink</span>( <span class="pl-s"><span class="pl-pds">"</span>sema<span class="pl-pds">"</span></span> );
    <span class="pl-c1">sem_close</span>( semaforo );
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>Compilamos: <strong>gcc semaforo.c -o semaforo -pthread</strong></p>

<p>Ejecutamos: <strong>./semaforo</strong></p>

<blockquote>
<p>Hilo ENTRO a seccion critica</p>

<p>Hilo SALIO a seccion critica</p>

<p>Hilo ENTRO a seccion critica</p>

<p>Hilo SALIO a seccion critica</p>

<p>Hilo ENTRO a seccion critica</p>

<p>Hilo SALIO a seccion critica</p>
</blockquote>

<ul>
<li>Ejemplo en <strong>C++</strong>: Calculamos el numero pi con 4 hilos con la ayuda de <a href="https://es.wikipedia.org/wiki/Serie_de_Leibniz">Serie de Leibniz</a> </li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>thread<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>

<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
vector&lt;<span class="pl-k">double</span>&gt; <span class="pl-en">valorCal</span>( <span class="pl-c1">4</span>, <span class="pl-c1">0.0</span> ), limites;

<span class="pl-k">void</span> <span class="pl-en">calcularIntervalo</span> (<span class="pl-k">int</span> index)
{
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = limites[<span class="pl-c1">index</span>]; i &lt; limites[<span class="pl-c1">index</span>+<span class="pl-c1">1</span>]; i++)
        <span class="pl-k">if</span> (i % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>)
            valorCal[<span class="pl-c1">index</span>] += <span class="pl-c1">1.0</span>/(<span class="pl-c1">2</span>*i+<span class="pl-c1">1</span>);
        <span class="pl-k">else</span>
            valorCal[<span class="pl-c1">index</span>] -= <span class="pl-c1">1.0</span>/(<span class="pl-c1">2</span>*i+<span class="pl-c1">1</span>);
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    <span class="pl-c">// Creamos nuestro limites</span>
    <span class="pl-k">int</span> numeroSerie = <span class="pl-c1">1000000000</span>;
    limites.<span class="pl-c1">push_back</span>( <span class="pl-c1">0</span> );
    limites.<span class="pl-c1">push_back</span>( numeroSerie/<span class="pl-c1">4</span> );
    limites.<span class="pl-c1">push_back</span>( numeroSerie/<span class="pl-c1">2</span> );
    limites.<span class="pl-c1">push_back</span>( <span class="pl-c1">3</span>*(numeroSerie/<span class="pl-c1">4</span>) );
    limites.<span class="pl-c1">push_back</span>( numeroSerie );

    <span class="pl-c">// Creamos a hilos</span>
    thread hilos[<span class="pl-c1">4</span>];

    <span class="pl-c">// Inicializamos nuestros hilos</span>
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">4</span>; i++)
        hilos[i] = <span class="pl-c1">thread</span>( calcularIntervalo, i );

    <span class="pl-c">// Esperemos a que nuestros hilos terminen</span>
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">4</span>; i++)
        hilos[i].<span class="pl-c1">join</span>();

    <span class="pl-c">// Calculamos nuestra respuesta</span>
    <span class="pl-k">double</span> answer = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">4</span>; i++)
        answer += valorCal[i];
    answer *= <span class="pl-c1">4</span>;
    <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span>EL valor de pi es:<span class="pl-cce">\t</span><span class="pl-c1">%.20f</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, answer );
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>Compilar: <strong>g++ pi.cpp -o pi -std=c++11 -pthread</strong></p>

<p>Ejecutar: <strong>./pi</strong></p>

<blockquote>
<p>EL valor de pi es:    3.14159265258921038821</p>
</blockquote>

<ul>
<li>Ejemplo en <strong>Java</strong>:</li>
</ul>
<p>Un grupo de personas trata de ir de una isla(Oahu) a la otra(Molokai) con un solo bote.</p>
<p><img src="https://s1-ssl.dmcdn.net/hjNxe/x240-XWg.jpg" alt=""></p>

<p>Reglas:</p>
<ul>
<li>Cada persona es un hilo.</li>
<li>La persona puede ser un adulto o un niño.</li>
<li>Pueden ir dos niños en el bote o solo un adulto.</li>
<li>El bote necesita como mínimo un piloto./li>
<li>las personas solo se pueden comunicar con los que estén en la misma isla.</li>
<li>Siempre hay mínimo dos niños.</li>
</ul>

<p>El principal objetivo del ejemplo es mostrar la sincronización de los hilos, la solución al problema consiste en llevar dos niños
a Molokai, hacer que uno se devuelva con el bote, subir un adulto en oahu, cuando este llegue a Molokai se devolverá el otro niño
que estaba ahí, y en Oahu se volverán a subir dos niños, este proceso se repetirá hasta que todas las personas estén en Oahu,
hay que tener en cuenta que no hay algo como unidad principal que controle cuando pasará cada persona, cada hilo deberá saber cuando
ejecutar sus instrucciones dependiendo de la sincronización con los otros</p>
<pre class="prettyprint">

import java.util.concurrent.Semaphore;

//extiende de thread y sobreescribe run sin nada
public class Persona extends Thread{

	int Tamano;
	String ubicacion;
	static String boatUbication="Oahu";
	public static String getBoatUbication() {
		return boatUbication;
	}

	public static void setBoatUbication(String boatUbication) {
		Persona.boatUbication = boatUbication;
	}

	public Persona(int tamano, String ubicacion) {
		super();
		this.Tamano = tamano;
		this.ubicacion = ubicacion;
	}

	@Override
    public void run() {

	}



}



import java.util.logging.Level;
import java.util.logging.Logger;

//extiende de persona
public class Adult extends Persona {
	public Adult() {
		super(2, "Oahu");
	}
	//sobreescribe run
	@Override
    public void run() {
		//mientras no hayan pasado todas las personas
		while(Boat.ContMolokai < Boat.ContTotalPersonas){
		 try {
			 //semaforo encargado de que un niño y adulto no luchen por el bote
			 Boat.classExclus.acquire();
             if (this.ubicacion.equals("Oahu") && boatUbication.equals(this.ubicacion) && Boat.ContChildBack%2!=0 && Boat.ContAdultOahu != 0){
            	 //si ve que puede pasar lo hace, adquiere las dos posiciones del bote
            	 Boat.available.acquire();
            	 Boat.available.acquire();
            	 Boat.bg.AdultRowToMolokai();
            	 this.ubicacion="Molokai";
            	 boatUbication="Molokai";
            	 Boat.ContMolokai++;
           		 Boat.ContOahu--;
           		 Boat.ContAdultOahu--;
           		 //al llegar libera las dos posiciones del bote
            	 Boat.available.release();
            	 Boat.available.release();
             }

             Boat.classExclus.release();
         } catch (InterruptedException ex) {
             Logger.getLogger(Child.class.getName()).log(Level.SEVERE, null, ex);
         }
	}
	}
}


import java.util.concurrent.Semaphore;
import java.util.logging.Level;
import java.util.logging.Logger;

//parecida a Adult
public class Child extends Persona {
	public Child() {
		super(1, "Oahu");
	}
	@Override
    public void run() {
		while(Boat.ContMolokai < Boat.ContTotalPersonas ){
		 try {
			 Boat.classExclus.acquire();
             if (this.ubicacion.equals("Oahu") && boatUbication.equals(this.ubicacion) && (Boat.ContChildBack%2==0 || Boat.ContAdultOahu == 0) ){
            	 //a diferencia del adulto el niño solo adquiere una posicion del bote
            	 Boat.available.acquire();
            	 Boat.UbicacionDispon--;
            	 if (Boat.UbicacionDispon==1) Boat.bg.ChildRowToMolokai();
            	 this.ubicacion="Molokai";
            	 Boat.ContMolokai++;
            	 Boat.ContOahu--;
            	 if(Boat.UbicacionDispon==0){
            		 Boat.bg.ChildRideToMolokai();
            		 boatUbication="Molokai";
            		 Boat.UbicacionDispon=2;
            	 }
            	 Boat.available.release();
             }
             //parte de la seccion critica encargada de que el niño regrese desde Molokai a Oahu
            	 if (this.ubicacion.equals("Molokai") && boatUbication.equals(this.ubicacion) && (Boat.ContMolokai < Boat.ContTotalPersonas ) ){
            		 //para evitar que se regresen dos niños el niño adquiere las dos posiciones
            		 //del bote
            		 Boat.available.acquire();
            		 Boat.available.acquire();
            		 Boat.bg.ChildRowToOahu();
                	 this.ubicacion="Oahu";
                	 boatUbication="Oahu";
                	 Boat.ContMolokai--;
                	 Boat.ContOahu++;
                	 Boat.ContChildBack++;
                	 //llega y libera las dos posiciones
                	 Boat.available.release();
                	 Boat.available.release();
            	 }

            	 Boat.classExclus.release();
         } catch (InterruptedException ex) {
             Logger.getLogger(Child.class.getName()).log(Level.SEVERE, null, ex);
         }

		}
	}

}



import java.util.Scanner;
import java.util.concurrent.Semaphore;
import java.util.LinkedList;

public class Boat {
	//se instancian los dos semaforos
	public static Semaphore available = new Semaphore(2, true);
	public static Semaphore classExclus = new Semaphore(1, true);
	static Scanner sc = new Scanner(System.in);
	//contadores para la comunicacion
	static int childrenTot=0;
	static int adultTot=0;
	static int ContChilds=0;
	static int ContAdults=0;
	static int ContTotalPersonas=0;
	static int ContOahu=0;
	static int ContMolokai=0;
	static int ContAdultOahu=0;
	static int UbicacionDispon=2;
	static int ContChildBack=0;

	//arreglo de personas
	static LinkedList<Child> ChildList = new LinkedList<Child>();
	static LinkedList<Adult> AdultList = new LinkedList<Adult>();
	static BoatGrader bg= new BoatGrader();

	//se crean los hilos
	static public void begin(){
		for(Child element : ChildList){
			element.start();


		}
		for(Adult element : AdultList){
			element.start();

		}
		//al terminar los hilos hacen join con el hilo principal
		for(Child element : ChildList){
			try {
				element.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		for(Adult element : AdultList){
			try {
				element.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}



	}

	public static void main(String args[]) {
		//entradas del programa
		while (childrenTot< 2){
			System.out.println("Introduzca el numero de niños (mayor a 1): ");
			childrenTot=sc.nextInt();
		}
		System.out.println("Introduzca el numero de adultos: ");
		adultTot=sc.nextInt();
	    for (int i=0;i< childrenTot;i++){
	    	ChildList.add(new Child());
	    	ContChilds++;
	    }
	    for (int i=0;i< adultTot;i++){
	    	AdultList.add(new Adult());
	    	ContAdults++;
	    }
	    ContTotalPersonas=ContChilds+ContAdults;
	    ContAdultOahu=ContAdults;
		ContOahu=ContTotalPersonas;

	    Boat.begin();
	    System.out.println("llegaron "+ContMolokai+" personas");
	}
}
</pre>
<p>ejecución:</p>
<pre class="prettyprint">
  Introduzca el numero de niños (mayor a 1):
  3
  Introduzca el numero de adultos:
  5
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  **Child rowing to Oahu.
  **Adult rowing to Molokai.
  **Child rowing to Oahu.
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  **Child rowing to Oahu.
  **Adult rowing to Molokai.
  **Child rowing to Oahu.
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  **Child rowing to Oahu.
  **Adult rowing to Molokai.
  **Child rowing to Oahu.
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  **Child rowing to Oahu.
  **Adult rowing to Molokai.
  **Child rowing to Oahu.
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  **Child rowing to Oahu.
  **Adult rowing to Molokai.
  **Child rowing to Oahu.
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  **Child rowing to Oahu.
  **Child rowing to Molokai.
  **Child arrived on Molokai as a passenger.
  llegaron 8 personas


</pre>
<ul>
<li>Ejemplo en <strong>Go</strong>:</li>
</ul>
<pre class="prettyprint">
  package main
  import(
  	"fmt"
  	"time"
  )
  func main() {
      fmt.Println("iniciando")
      go printForward()
      go printBackwards()
  	time.Sleep(time.Second * 5)
      fmt.Println("terminando")
  }
  func printForward() {
      for i := 0; i < 10; i++ {
          fmt.Println(i)
          time.Sleep(time.Millisecond)
      }
  }
  func printBackwards() {
      for i := 10; i <= 20; i++ {
          fmt.Println(i)
          time.Sleep(time.Millisecond)
      }
  }
</pre>
<p>En Go tenemos rutinas que tienen su propio stack, aunque estos no son hilos como tal, pero si se pueden aprovechar de esta forma</p>
<pre class="prettyprint">
package main
import(
	"fmt"
	"time"
)
func main() {
    c := make(chan string)
    go echo(c)
    c < - "Hola"
    mensaje := < - c
    fmt.Println(mensaje)
}

func echo(c chan string) {
    msg := < - c
    time.Sleep(time.Second * 1)
    c < - fmt.Sprintf("Mensaje recibido: %s", msg)
}

salida= Mensaje recibido:Hola
</pre>

<p>En Go tenemos el Select es como un switch, pero que espera mensajes en canales.
Su finalidad es comunicar, no comparar valores. </p>
<pre class="prettyprint">
package main
import(
  "fmt"
  "time"
)
func main() {
    process1 := processExpensiveTransaction()
    process2 := processExpensiveTransaction()
    for i := 0; i < 2; i++ {
        select {
            case msg1 := <- process1:
                fmt.Println("Proceso 1 termino con status ", msg1)                
            case msg2 := <- process2:
                fmt.Println("Proceso 2 termino con status ", msg2)                
        }
    }
}

func processExpensiveTransaction() chan string {
    c := make(chan string)
    go func() {
        time.Sleep(time.Duration(rand.Intn(6)) * time.Second)
        c <- "ok"
    } ()    
    return c
}
</pre>

<ul>
<li>Ejemplo de concurrecia en <strong>Erlang</strong>:</li>
</ul>
<p>
  La función spawn en Erlang nos permiete crear un proceso en paralelo.
</p>
<pre class="prettyprint">
  -module(helloworld).
  -export([start/0]).
  start() ->
    Pid = spawn(fun() -> server("Hello") end),

  server(Message) ->
    io:fwrite("~p",[Message]).
</pre>
<p>
  La salida es la siguiente:
</p>
<blockquote>
  "Hello"
</blockquote>

<p>
   El operador ! nos permite enviar mensajes a los procesos.
</p>
<pre class="prettyprint">
  -module(helloworld).
  -export([start/0]).
  start() ->
    Pid = spawn(fun() -> server("Hello") end),
    Pid ! {hello}.

  server(Message) ->
    io:fwrite("~p",[Message]).
</pre>
<p>
  La salida es la siguiente:
</p>
<blockquote>
  "Hello"
</blockquote>


<p>
   receive permite recibir mensajes que son enviados a los procesos.
</p>
<pre class="prettyprint">
  -module(helloworld).
  -export([loop/0,start/0]).

  loop() ->
     receive
        {rectangle, Width, Ht} ->
           io:fwrite("Area of rectangle is ~p~n" ,[Width * Ht]),
           loop();
        {circle, R} ->
        io:fwrite("Area of circle is ~p~n" , [3.14159 * R * R]),
        loop();
     Other ->
        io:fwrite("Unknown"),
        loop()
     end.

  start() ->
     Pid = spawn(fun() -> loop() end),
     Pid ! {rectangle, 6, 10},
     Pid ! {circle, 6},
     Pid ! {square, 4, 4}.
</pre>
<p>
  La salida es la siguiente:
</p>
<blockquote>
  Area of rectangle is 60<br>
  Area of circle is 113.09723999999999<br>
  Unknown<br>
</blockquote>

<h1>
<a id="presentacion" class="anchor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Presentación</h1>
<a href="https://drive.google.com/open?id=0B_B-BoNU4ZaIOTNrUWlWXzBjNmc">Enlace</a>
<br>
<a href="https://docs.google.com/a/unal.edu.co/presentation/d/1qwH2qt_KMMoaIlgN5xVuBpEylf9bC_TNVD3nE5foKBo/edit?usp=sharing">Enlace 2</a>

<h1>
<a id="taller" class="anchor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Taller</h1>
<a href="https://drive.google.com/open?id=0B_B-BoNU4ZaIcEZQX2ttZU1mVFk">Enlace</a>
<br>
<a href="https://docs.google.com/a/unal.edu.co/document/d/1wLW-AtC3ap86P4z547Tqse0R3X7bGChVAk6QHdkfu4E/edit?usp=sharing">Enlace 2</a>



<h1>
<a id="referencias" class="anchor" href="#referencias" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Referencias</h1>

<ul>
<li style="background-color: #FFFFFF;"><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://go-tour-es.appspot.com/#1">https://go-tour-es.appspot.com/#1</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://geekytheory.com/concurrencia-en-javascript/">https://geekytheory.com/concurrencia-en-javascript/</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_3_01.pdf">http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_3_01.pdf</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www.genbetadev.com/python/multiprocesamiento-en-python-threads-a-fondo-introduccion">http://www.genbetadev.com/python/multiprocesamiento-en-python-threads-a-fondo-introduccion</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_1_01.pdf">http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_1_01.pdf</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-multicore-programming-primer-january-iap-2007/lecture-notes-and-video/l4-introduction-to-concurrent-programming/">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-multicore-programming-primer-january-iap-2007/lecture-notes-and-video/l4-introduction-to-concurrent-programming/</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://sites.google.com/a/unal.edu.co/sistemas-operativos/">https://sites.google.com/a/unal.edu.co/sistemas-operativos/</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://www.fing.edu.uy/tecnoinf/mvd/cursos/so/material/teo/so07-concurrencia.pdf">https://www.fing.edu.uy/tecnoinf/mvd/cursos/so/material/teo/so07-concurrencia.pdf</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www2.ulpgc.es/hege/almacen/download/20/20233/tema1.pdf">http://www2.ulpgc.es/hege/almacen/download/20/20233/tema1.pdf</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://concurrencia-go.appspot.com/">http://concurrencia-go.appspot.com/</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://buguroo.com/es/concurrencia-real-en-python">https://buguroo.com/es/concurrencia-real-en-python</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www.noesispoint.com/jsp/scjp/SCJPch12.htm">http://www.noesispoint.com/jsp/scjp/SCJPch12.htm</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www.javaworld.com/article/2076774/java-concurrency/programming-java-threads-in-the-real-world--part-1.html">http://www.javaworld.com/article/2076774/java-concurrency/programming-java-threads-in-the-real-world--part-1.html</a></li>
<li>Abraham Silberschatz-Operating System Concepts (9th,2012.12)</li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://wiki.inf.utfsm.cl/index.php?title=Monitores#.C2.BFQu.C3.A9_son_los_Monitores.3F
">http://wiki.inf.utfsm.cl/index.php?title=Monitores#.C2.BFQu.C3.A9_son_los_Monitores.3F
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://1984.lsi.us.es/wiki-ssoo/index.php/Mensajería">http://1984.lsi.us.es/wiki-ssoo/index.php/Mensajería
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://sistop.gwolf.org/html/03_planificacion_de_procesos.html#sec-1">http://sistop.gwolf.org/html/03_planificacion_de_procesos.html#sec-1</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://es.wikipedia.org/wiki/Problema_productor-consumidor">https://es.wikipedia.org/wiki/Problema_productor-consumidor</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://www.slant.co/topics/6024/~programming-languages-for-concurrent-programming
">https://www.slant.co/topics/6024/~programming-languages-for-concurrent-programming
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://blanchardspace.wordpress.com/2016/08/19/rust-lenguaje/">https://blanchardspace.wordpress.com/2016/08/19/rust-lenguaje/</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://www.genbetadev.com/frameworks/elixir
">https://www.genbetadev.com/frameworks/elixir
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://www.genbetadev.com/frameworks/elixir
">https://www.genbetadev.com/frameworks/elixir
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://www.ecured.cu/Lenguaje_de_programaci%C3%B3n_Go
">https://www.ecured.cu/Lenguaje_de_programaci%C3%B3n_Go
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://wiki.haskell.org/Es/Introduccion
">https://wiki.haskell.org/Es/Introduccion
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://g3ortega.com/programming_languages/2016/06/10/crystal-lenguaje-de-programacion-el-por-que-y-el-como.html">http://g3ortega.com/programming_languages/2016/06/10/crystal-lenguaje-de-programacion-el-por-que-y-el-como.html</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://en.wikipedia.org/wiki/Crystal_(programming_language)
">https://en.wikipedia.org/wiki/Crystal_(programming_language)
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="https://www.tutorialspoint.com/erlang/erlang_concurrency.htm">https://www.tutorialspoint.com/erlang/erlang_concurrency.htm</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://concurrencia-go.appspot.com/
">http://concurrencia-go.appspot.com/
</a></li>
<li><a style="background-color: #FFFFFF;color: blue; text-align: left;" href="http://www.ctr.unican.es/asignaturas/procodis_3_II/Doc/Procodis_1_01.pdf">Programación concurrente - J.M. Drake </a></li>
</ul>
</div>

<h1>
<a id="intregrantes" class="anchor" href="#intregrantes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Intregrantes</h1>

<ul>
<li>Bryam Diaz</li>
<li>Santiago Marquez</li>
<li>Christian Vaca</li>
<li>Kevin Mendez Paez</li>
<li>Diego Alejandro Guevara Rocha</li>
<li>Jhon Emmanuel Torres</li>
<li>Raul Ramirez Penagos</li>
<li>Diego Rodriguez</li>
<li>Fabian David Conejo</li>
<li>Milder Hernandez</li>
</ul>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/ferestrepoca/paradigmas-de-programacion/archive/gh-pages.zip" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/ferestrepoca/paradigmas-de-programacion/archive/gh-pages.tar.gz" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="http://ferestrepoca.github.io/paradigmas-de-programacion/"></a> is maintained by <a href="http://dis.unal.edu.co/~ferestrepoca/">Felipe Restrepo.</a></p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>


  </body>
</html>
