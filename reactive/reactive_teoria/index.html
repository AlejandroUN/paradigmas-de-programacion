<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">

    <title>Programación Reactiva</title>

    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="css/stroke.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/animate.css">
    <link rel="stylesheet" type="text/css" href="css/prettyPhoto.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <link rel="stylesheet" type="text/css" href="js/syntax-highlighter/styles/shCore.css" media="all">
    <link rel="stylesheet" type="text/css" href="js/syntax-highlighter/styles/shThemeRDark.css" media="all">

    <link rel="stylesheet" type="text/css" href="css/custom.css">

    <link rel="stylesheet"
          href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.1/build/styles/default.min.css">

</head>

<body>
<button onclick="topFunction()" id="myBtn" title="Go to top"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>

<script>
    var mybutton = document.getElementById("myBtn");
    window.onscroll = function() {scrollFunction()};
    function scrollFunction() {
        if (document.body.scrollTop > 1000 || document.documentElement.scrollTop > 1000) {
            mybutton.style.display = "block";
        } else {
            mybutton.style.display = "none";
        }
    }
    function topFunction() {
        window.scrollTo({ top: 0, behavior: 'smooth' })
        document.documentElement.scrollTo({ top: 0, behavior: 'smooth' })
    }

    document.addEventListener("DOMContentLoaded", () => {
        document.querySelector('#mode').addEventListener('click',()=>{
            document.querySelector('html').classList.toggle('dark');
        })
    });


</script>

<div id="wrapper">

    <div id="mode" >
        <div class="dark">
            <svg aria-hidden="true" viewBox="0 0 512 512">
                <title>lightmode</title>
                <path fill="currentColor" d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path>
            </svg>
        </div>
        <div class="light">
            <svg aria-hidden="true" viewBox="0 0 512 512">
                <title>darkmode</title>
                <path fill="currentColor" d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"></path>
            </svg>
        </div>
    </div>

    <div class="container">

        <section id="top" class="section docs-heading">

            <div class="row">
                <div class="col-md-12">
                    <div class="big-title text-center">
                        <h1>Programación Reactiva</h1>
                    </div>
                    <!-- end title -->
                </div>
                <!-- end 12 -->
            </div>
            <!-- end row -->

            <hr>

        </section>
        <!-- end section -->

        <div class="row">

            <div class="col-md-3">
                <nav class="docs-sidebar" data-spy="affix" data-offset-top="300" data-offset-bottom="200" role="navigation">
                    <ul class="nav">
                        <li><a href="#line1">Introducción</a></li>
                        <li><a href="#line3">Características </a></li>
                        <li><a href="#line4">Patrón de Diseño <i>Observer</i> </a></li>
                        <li><a href="#line5">Ventajas </a></li>
                        <li><a href="#line6">Desventajas </a></li>
                        <li><a href="#lineB1">Evolución del paradigma</a></li>
                        <li><a href="#lineB2">El término "Reactive"</a></li>
                        <li><a href="#line7">Lenguajes de Programación</a></li>
                        <li><a href="#line8">Ejemplos</a>
                            <ul class="nav">
                                <li><a href="#line8_1">RxPY</a></li>
                                <li><a href="#line8_2">RxJava</a></li>
                                <li><a href="#line8_3">RxJS</a></li>
                            </ul>
                        </li>
                        <li><a href="#line9">Aplicaciones</a></li>
                        <li><a href="#line10">Referencias</a></li>
                    </ul>
                </nav >
            </div>
            <div class="col-md-9">


                <section id="line1" class="section" style="padding: 0px;">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Introducción <hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-12">
                            <h3 class="dark-text">¿Qué es la programación reactiva?</h3>
                            <p>Es un paradigma enfocado en el trabajo con flujos de datos finitos o infinitos de manera asíncrona, es decir que las aplicaciones reaccionan a los cambios ejecutando una serie de eventos.</p>
                            <p>Este paradigma esta enfocado principalmente en el manejo de flujos de datos asíncronos y en el uso eficiente de recursos. Los sistemas reactivos reaccionan a los datos que fluyen continuamente ejecutando una serie de eventos, esto es porque siguen el patrón de diseño Observer;
                                cuando hay un cambio de estado en un objeto, los otros objetos son notificados y actualizados. Por lo tanto, en lugar de estar preguntando los cambios, los eventos se realizan de forma asíncrona para que los observadores puedan procesarlos.</p>
                            <p>La motivación detrás de este nuevo paradigma procede de la necesidad de responder a las limitaciones de escalado presentes en los modelos de desarrollo actuales, que se caracterizan por su desaprovechamiento del uso de la CPU debido al I/O,
                                el sobreuso de memoria (enormes thread pools) y la ineficiencia de las interacciones bloqueantes.</p>

                            <img src="images/Observer.svg" alt="" class="img-responsive img-thumbnail">


                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                </section>
                <!-- end section -->

                <section id="line3" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Características<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <h4>Actores</h4>

                    <p><b>Flujo de datos:</b> Son datos que se van modificando cada cierto tiempo, y que puede tener interés observar en tiempo real.</p>
                    <p><b>Observable:</b> Un componente que puede ser observado, y que se encargará de informar cuando ese flujo de datos se modifique.</p>
                    <p><b>Observador:</b> Es el elemento que observa esas modificaciones. Cuando el dato se modifica, se notifica al componente que lo está utilizando.
                        Normalmente este observer necesita suscribirse cuando quiere empezar a recibir datos, y desuscribirse cuando ya no le interesan más esos datos.
                    </p>
                    <p><b>Dispatchers:</b> En cada framework de programación reactiva se llaman de una forma distinta, pero básicamente son un conjunto de hilos donde se van a ejecutar las operaciones, y unas reglas que optimizan su uso para ser lo más eficientes posibles.</p>
                    <p><b>Operadores:</b> Existen montones de operadores que nos permiten modificar y combinar flujos de datos, y conocerlos todos es muy complicado. Dependen de las librerías.</p>

                    <hr>

                    <h4>Manejo de flujos de datos</h4>

                    <p>Basado en datos que fluyen continuamente, los sistemas reactivos reaccionan a los datos ejecutando una serie de eventos.</p>

                    <hr>

                    <h4>Patrón de Diseño <i>Observer</i></h4>

                    <p>La programación reactiva sigue el patrón de diseño Observer; cuando hay un cambio de estado en un objeto, los otros objetos son notificados y actualizados acorde. Por lo tanto, en lugar de sondear eventos para los cambios, los eventos se realizan de forma asíncrona para que los observadores puedan procesarlos.</p>

                    <hr>

                    <h4>Uso eficiente de recursos</h4>

                    <p>Utilizando E/S asíncrona, la idea es simple: disminuir el uso ineficiente de recursos usando recursos que de lo contrario estarían inactivos, ya que permanecen a la espera de actividad de E/S. </p>

                    <hr>

                    <h4>Liberación del cliente</h4>

                    <p>Los nuevos datos se notifican a los clientes en vez de tener que solicitarlos, debido a que la E/S asíncrona invierte el diseño normal del procesamiento de E/S. Este enfoque libera al cliente para hacer otras cosas mientras espera nuevas notificaciones.</p>

                    <hr>

                    <h4>Demasiadas notificaciones</h4>

                    <p>Existe el riesgo de que demasiadas notificaciones desborden al cliente. </p>

                    <hr>

                    <h4>Rechazar el trabajo que no se puede manejar</h4>

                    <p>Un aspecto fundamental de control de flujo en sistemas distribuidos es que el cliente debe ser capaz de rechazar el trabajo que no puede manejar. En la programación reactiva, la capacidad del cliente para señalizar cuánto trabajo puede manejar se llama <b>contrapresión</b>. </p>

                </section>
                <!-- end section -->

                <section id="line4" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Patrón de Diseño <i>Observer</i><hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>En este patrón, tenemos un objeto Observable al que podemos suscribirnos, y cada vez que haya un cambio en su valor seremos informados. A esto se le conoce como Publicador-Suscriptor. </p>

                    <h4> Finalidad </h4>

                    <p>El patrón Observer trabaja con dos tipos de actores: por un lado, el sujeto, es decir, el objeto cuyo estado quiere vigilarse a largo plazo. Por otro lado, están los objetos observadores, que han de ser informados de cualquier cambio en el sujeto.
                        Sin el patrón Observer, los objetos observadores tendrían que solicitar al sujeto regularmente que les enviase actualizaciones acerca de su estado (status updates). Cada una de estas solicitudes conllevaría tiempo de computación y requeriría, además, ciertos recursos de hardware.</p>
                    <hr>
                    <h4>Funcionamiento y estructura</h4>
                    <ol type="1">
                        <li>El <b>Notificador</b> envía eventos de interés a otros objetos. Esos eventos ocurren cuando el notificador cambia su estado o ejecuta algunos comportamientos. Los notificadores contienen una infraestructura de suscripción que permite a nuevos y antiguos suscriptores abandonar la lista.</li>
                        <li>Cuando sucede un nuevo evento, el notificador recorre la lista de suscripción e invoca el método de notificación declarado en la interfaz suscriptora en cada objeto suscriptor.</li>
                        <li>La interfaz <b>Suscriptora</b> declara la interfaz de notificación. En la mayoría de los casos, consiste en un único método <i>actualizar</i>. El método puede tener varios parámetros que permitan al notificador pasar algunos detalles del evento junto a la actualización.</li>
                        <li>Los <b>Suscriptores Concretos</b> realizan algunas acciones en respuesta a las notificaciones emitidas por el notificador. Todas estas clases deben implementar la misma interfaz de forma que el notificador no esté acoplado a clases concretas.</li>
                        <li>Normalmente, los suscriptores necesitan cierta información contextual para manejar correctamente la actualización. Por este motivo, a menudo los notificadores pasan cierta información de contexto como argumentos del método de notificación. El notificador puede pasarse a sí mismo como argumento, dejando que los suscriptores extraigan la información necesaria directamente.</li>
                        <li>El <b>Cliente</b> crea objetos tipo notificador y suscriptor por separado y después registra a los suscriptores para las actualizaciones del notificador.</li>
                    </ol>
                    <div class="text-center">
                        <img class="img-responsive img-thumbnail" src="images/structure.png" alt="">
                    </div>


                </section>
                <!-- end section -->


                <section id="line5" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Ventajas<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <h4>Escalabilidad</h4>

                    <p>A través de la Programación Reactiva, se obtiene una implementación que tiende a aislar los fallos a través de una escalabilidad horizontal, es decir, se obtiene una capacidad de escalar horizontalmente y de manera rápida.</p>

                    <hr>

                    <h4>Ahorro</h4>

                    <p>Una consecuencia directa de utilizar de manera eficiente los recursos es invertir menos en servidores y centros de datos por lo que se puede realizar más con menos recursos y procesar cargas de trabajo mal altas con menos hilos.</p>


                </section>
                <!-- end section -->

                <section id="line6" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Desventajas<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <h4>Modificación</h4>

                    <p>Se modifica el estilo de la programación clásica.</p>

                    <hr>

                    <h4>Riesgos y dificultades</h4>

                    <p>Dada la falta de experiencia en este campo, se pueden generar riesgos a fallos y problemas a la hora de depurar los errores, así como problemas en el entendimiento clásico del concepto.</p>


                </section>
                <!-- end section -->

                <section id="lineB1" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Evolución del paradigma<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>
                        Los orígenes de la programación reactiva se remontan, probablemente, a la década de 1970,
                        pero esta empezó a resonar en la década del 2010, al mismo tiempo que comenzó el auge de
                        los microservicios y los procesadores multinúcleo.
                        <br><br>
                        Desde entonces, dicho paradigma ha evolucionado de manera significativa y, por este motivo,
                        las librerías que lo implementan pueden clasificarse en generaciones de acuerdo a su grado
                        de madurez, según la categorización propuesta por el autor
                        <a href="https://hu.linkedin.com/in/david-karnok-725b3189">
                            David Karnok</a> en el año 2016, la cual se describe a continuación:
                    </p>

                    <hr>

                    <h4>Generación 0</h4>

                    <p>
                        Consiste, principalmente, de la API <b>java.util.Observable</b> y de otras API basadas en
                        <i>callbacks</i>, tal como <b>addXXXListener</b> en Swing, AWT y Android. <br><br>
                        Los inconvenientes que presentaban las herramientas de esta generación eran las
                        deficiencias de composición y el hecho de que, por sí mismas, resultaban bastante limitadas.
                    </p>

                    <hr>

                    <h4>Primera generación</h4>

                    <p>
                        Una vez que Erik Meijer y el equipo de Microsoft reconocieron y abordaron las deficiencias,
                        nació la primera generación de bibliotecas de programación reactiva: Rx.NET alrededor de
                        2010, Reactive4Java en 2011 y las primeras versiones de RxJava en 2013.
                        <br><br>
                        Algunos de los inconvenientes encontrados consistieron en que, al implementar las interfaces
                        <b>IObservable/IObserver</b> no se podían cancelar las secuencias en ejecución usando
                        el operador <b>take()</b>, además del problema de la falta de <i>backpressure</i>.
                    </p>

                    <hr>

                    <h4>Segunda generación</h4>

                    <img src="images/subscribe.png" alt="" class="img-responsive img-thumbnail">

                    <p>
                        El equipo de RxJava identificó estas deficiencias y se diseñó una nueva arquitectura. En
                        esta se introdujo: la clase <b>Subscriber</b>, la cual puede decir si está interesada
                        en más eventos o no; la interfaz <b>Producer</b>, para señalar la cantidad de elementos
                        que un <i>Subscriber</i> puede procesar a la vez, y el método <b>lift()</b>, que permite una
                        transformación funcional entre <i>Subscribers</i>.
                        <br><br>
                        No obstante, esta solución era un poco torpe y limitaba algunas optimizaciones, además
                        de que era incompatible con los puntos de vista de otras bibliotecas reactivas que
                        comenzarían a surgir más adelanate.
                    </p>

                    <hr>

                    <h4>Tercera generación</h4>

                    <p>
                        Ingenieros de varias compañías se juntaron y crearon la especificación <b>Reactive
                        Streams</b>. Algunos ejemplos de librerías que pertenecen a esta generación son
                        RxJava 2.x, Project Reactor y Akka-Streams.
                    </p>

                    <hr>

                    <h4>Cuarta generación</h4>

                    <p>
                        Algunas de estas librerías se reimplementaron, lo cual condujo al establecimiento de
                        la libería <i>reactive-streams-commons</i>, a la construcción de ciertos operadores
                        fundacionales y al diseño de componentes de optimización que pasaron a recibir el nombre
                        de <b>operator-fusion</b>. Comparada con la generación anterior, aunque lucen similares
                        en el exterior, en el interior poseen cambios significativos que permitieron una
                        reducción aún mayor de los gastos generales.
                    </p>

                    <hr><br>

                    <p>
                        Adicionalmente, este autor especula que de la quinta generación en adelante, la arquitectura
                        de <i>Reactive-Streams</i> requeriría ciertas extensiones para soportar operaciones
                        reactivas de entrada y salida en la forma de secuencias bidireccionales, entre otros
                        cambios que, en ese punto, estaban abiertos a discusión.
                    </p>


                </section>
                <!-- end section -->

                <section id="lineB2" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">El término "Reactive"<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <p>
                        La programación reactiva, al tratarse de un paradigma emergente que está en constante
                        actualización, suele confundirse con otros conceptos que también llevan la partícula
                        "reactive" en su nombre. Este término es muy amplio y, aunque algunas personas pueden
                        creer que las extensiones reactivas, los <i>streams</i> reactivos, los sistemas reactivos,
                        y la programación funcional reactiva (entre otras muchas) sean lo mismo, la verdad es
                        que existen diferencias importantes a considerar en todas ellas.
                    </p>

                    <hr>

                    <h4>Programación Funcional Reactiva (FRP)</h4>

                    <p>
                        Fue definida en 1997 por <a href="http://conal.net/">Conal Elliott</a> y Paul Hudak. De
                        acuerdo con una presentación que Elliott dio en el año 2015, titulada "The essence and
                        origins of FRP", el término había sido empleado incorrectamente para describir sistemas
                        como Elm, Bacon y extensiones reactivas. La diferencia principal entre la FRP y la
                        programación reactiva es que la primera opera en valores que cambian continuamente a
                        través del tiempo, mientras que la segunda opera en valores discretos que se emiten a
                        través del tiempo. La conferencia puede verse a continuación:
                    </p>

                    <video class="img-responsive img-thumbnail" src="https://vod-progressive.akamaized.net/exp=1642988475~acl=%2Fvimeo-prod-skyfire-std-us%2F01%2F1844%2F5%2F134223272%2F395828977.mp4~hmac=6265b1468e2174bceb3fbc2ec8c6f79cca230503d3abd79b8ab5a7437fccd296/vimeo-prod-skyfire-std-us/01/1844/5/134223272/395828977.mp4?filename=frp+final.mp4" controls></video>

                    <hr>

                    <h4>Extensiones y Streams Reactivos</h4>

                    <p>
                        Las extensiones reactivas, mejor conocidas como <b>"ReactiveX"</b> son un conjunto de
                        herramientas que implementan el paradigma de la programación reactiva (estas se cubrirán
                        a detalle <a href="#line7">más adelante</a>). <br><br>
                        Sin embargo, debido a que estas contienen una gran variedad de librerías y a la falta
                        de interoperabilidad entre ellas, surgieron los <i>Reactive Streams</i>. Esta fue una
                        iniciativa creada para proveer un estándar para las extensiones reactivas y
                        que lidiara con el procesamiento de flujo (<i>stream</i>) asincrónico con contrapresión
                        sin bloqueo (<i>non-blocking backpressure</i>); es decir, se buscó unificar las
                        librerías ya existentes.
                    </p>

                    <hr>

                    <h4>Sistemas reactivos</h4>

                    <p>
                        Los sistemas reactivos son un conjunto de principios de diseño arquitectónico para construir
                        sistemas modernos que estén bien preparados para satisfacer las crecientes demandas que
                        enfrentan las aplicaciones hoy en día. Sus especificaciones se pueden encontrar en línea
                        bajo el nombre de "Manifiesto Reactivo", tal como sigue a continuación:
                    </p>

                    <div class="intro2 clearfix">
                        <p>Los Sistemas Reactivos son:</p>
                        <p><b>Responsivos:</b> El sistema responde a tiempo en la medida de lo posible. La responsividad es la piedra angular de la usabilidad y la utilidad, pero más que esto, responsividad significa que los problemas pueden ser detectados rápidamente y tratados efectivamente. Los sistemas responsivos se enfocan en proveer tiempos de respuesta rápidos y consistentes, estableciendo límites superiores confiables para así proporcionar una calidad de servicio consistente. Este comportamiento consistente, a su vez, simplifica el tratamiento de errores, aporta seguridad al usuario final y fomenta una mayor interacción.</p>
                        <p><b>Resilientes:</b> El sistema permanece responsivo frente a fallos. Esto es aplicable no sólo a sistemas de alta disponibilidad o de misión crítica - cualquier sistema que no sea resiliente dejará de ser responsivo después de un fallo. La resiliencia es alcanzada con replicación, contención, aislamiento y delegación. Los fallos son manejados dentro de cada componente, aislando cada componente de los demás, y asegurando así que cualquier parte del sistema pueda fallar y recuperarse sin comprometer el sistema como un todo. La recuperación de cada componente se delega en otro componente (externo) y la alta disponibilidad se asegura con replicación allí donde sea necesario. El cliente de un componente no tiene que responsabilizarse del manejo sus fallos.</p>
                        <p><b>Elásticos:</b> El sistema se mantiene responsivo bajo variaciones en la carga de trabajo. Los Sistemas Reactivos pueden reaccionar a cambios en la frecuencia de peticiones incrementando o reduciendo los recursos asignados para servir dichas peticiones. Esto implica diseños que no tengan puntos de contención o cuellos de botella centralizados, resultando en la capacidad de dividir o replicar componentes y distribuir las peticiones entre ellos. Los Sistemas Reactivos soportan algoritmos de escalado predictivos, así como Reactivos, al proporcionar relevantes medidas de rendimiento en tiempo real. La elasticidad se consigue de forma rentable haciendo uso de plataformas con hardware y software genéricos.</p>
                        <p><b>Orientados a Mensajes:</b> Los Sistemas Reactivos confían en el intercambio de mensajes asíncrono para establecer fronteras entre componentes, lo que asegura bajo acoplamiento, aislamiento y transparencia de ubicación. Estas fronteras también proporcionan los medios para delegar fallos como mensajes. El uso del intercambio de mensajes explícito posibilita la gestión de la carga, la elasticidad, y el control de flujo, gracias al modelado y monitorización de las colas de mensajes en el sistema, y la aplicación de back-pressure cuando sea necesario. La mensajería basada en ubicaciones transparentes como medio de comunicación permite que la gestión de fallos pueda trabajar con los mismos bloques y semánticas a través de un cluster o dentro de un solo nodo. La comunicación No-bloqueante permite a los destinatarios consumir recursos sólo mientras estén activos, llevando a una menor sobrecarga del sistema.</p>
                        <p><br> Publicado en septiembre 16 2014. (v2.0) <a href="https://www.reactivemanifesto.org/es" target="_blank">El Manifiesto de Sistemas Reactivos.</a> </p>
                    </div>

                    <p>
                        Esta es uno de los conceptos que suele causar más confusiones, debido al hecho de que <b>usar
                        programación reactiva no necesariamente conduce a la formación de sistemas reactivos</b>. Aunque
                        el paradigma sí es útil para satisfacer ciertos requerimientos enunciados en el manifiesto, hace
                        falta considerar algunos puntos: <br><br>
                        De acuerdo al <i>white paper</i> "Reactive Programming versus Reactive Systems", escrito por
                        <a href="http://jonasboner.com/">Jonas Bonér</a> y <a href="https://viktorklang.com/">Viktor Clang</a>,
                        la programación reactiva es, generalmente, dirigida por eventos, mientras que los sistemas
                        reactivos son dirigidos por mensajes. La principal diferencia entre ambos consiste en que los
                        mensajes son inherentemente dirigidos (siempre tienen un destino), mientras que los eventos no:
                        estos son tan solo señales emitidas por un componente al alcanzar cierto estado.
                    </p>

                    <img src="images/soapbox.jpg" class="img-responsive img-thumbnail" alt="">

                    <p>
                        En un sistema dirigido por mensajes, los receptores esperan por la llegada de estos y reaccionan
                        a ellos, de lo contrario permanecen inactivos. Por otra parte, en un sistema dirigido por eventos,
                        los detectores de notificaciones están anclados a las fuentes de dichos eventos, de tal forma que
                        son invocados cuando el evento es emitido. En síntesis, un sistema dirigido por mensajes se centra
                        en los destinatarios, mientras que uno dirigido por eventos se enfoca en los emisores. <br><br>
                        De este modo, el uso exclusivo de programación reactiva puede hacer que la resiliencia sea más
                        difícil de lograr, pues las <i>callbacks</i> suelen ser anónimas y, por ende, no direccionables.
                        Es decir que si falla una de las cadenas del flujo de datos, entonces se debe reiniciar la cadena
                        y el cliente debe ser notificado (algo que no ocurre en un sistema dirigido por mensajes, que
                        tendría la capacidad de autorecuperarse sin involucrar al cliente). Sin embargo, si se integra
                        este paradigma con una arquitectura reactiva, este termina siendo de gran utilidad a la hora
                        de construir sistemas reactivos.
                    </p>

                </section>
                <!-- end section -->

                <section id="line7" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Lenguajes de Programación <hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-6">
                            <strong>ReactiveX</strong>
                            <p>Es un conjunto de herramientas que permiten que los lenguajes de programación imperativos operen en secuencias de datos independientemente de si los datos son síncronos o asincrónicos. Proporciona un conjunto de operadores de secuencia que operan en cada elemento de la secuencia. Es una implementación de programación reactiva y proporciona un modelo para que las herramientas se implementen en múltiples lenguajes de programación.
                            </p>
                            <p>ReactiveX es una combinación de las mejores ideas de
                                el patrón Observer, el patrón Iterator y la programación funcional Reactiva.</p>

                            <img src="images/reactivex.png" alt="" class="img-responsive img-thumbnail">

                        </div>

                        <div class="col-md-6">
                            <strong>Lenguajes</strong>

                            <p> Los siguientes lenguajes poseen una libreria basada en ReactiveX que les permite pertenecer al paradigma de la Programación reactiva </p>
                            <ul>
                                <li>Java: <a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
                                <li>JavaScript: <a href="https://github.com/ReactiveX/rxjs">RxJS</a></li>
                                <li>C#: <a href="https://github.com/Reactive-Extensions/Rx.NET">Rx.NET</a></li>
                                <li>C#(Unity): <a href="https://github.com/neuecc/UniRx">UniRx</a></li>
                                <li>Scala: <a href="https://github.com/ReactiveX/RxScala">RxScala</a></li>
                                <li>Clojure: <a href="https://github.com/ReactiveX/RxClojure">RxClojure</a></li>
                                <li>C++: <a href="https://github.com/Reactive-Extensions/RxCpp">RxCpp</a></li>
                                <li>Lua: <a href="https://github.com/bjornbytes/RxLua">RxLua</a></li>
                                <li>Ruby: <a href="https://github.com/Reactive-Extensions/Rx.rb">Rx.rb</a></li>
                                <li>Python: <a href="https://github.com/ReactiveX/RxPY">RxPY</a></li>
                                <li>Go: <a href="https://github.com/ReactiveX/RxGo">RxGo</a></li>
                                <li>Groovy: <a href="https://github.com/ReactiveX/RxGroovy">RxGroovy</a></li>
                                <li>JRuby: <a href="https://github.com/ReactiveX/RxJRuby">RxJRuby</a></li>
                                <li>Kotlin: <a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a></li>
                                <li>Swift: <a href="https://github.com/kzaher/RxSwift">RxSwift</a></li>
                                <li>PHP: <a href="https://github.com/ReactiveX/RxPHP">RxPHP</a></li>
                                <li>Elixir: <a href="https://github.com/alfert/reaxive">reaxive</a></li>
                                <li>Dart: <a href="https://github.com/ReactiveX/rxdart">RxDart</a></li>
                            </ul>
                        </div>
                    </div>
                    <!-- end row -->

                </section>
                <!-- end section -->

                <section id="line8" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Ejemplos<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_1">RxPY </h4>

                            <script src="https://gist.github.com/juankg214/e0f5ed1550993577ea302edbf10e775a.js"></script>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_2">RxJAVA </h4>

                            <script src="https://gist.github.com/juankg214/8b2862d91b272338c2fed1ecc580f0eb.js"></script>
                            <script src="https://gist.github.com/juankg214/a340b74659748cd55f194b67092ea6d6.js"></script>
                            <script src="https://gist.github.com/juankg214/72b16f25698e603d329637bbb2cee74f.js"></script>
                            <p>El siguiente ejemplo muestra una implementación pura en Java que busca simular un caso de programación reactiva,
                                en el que en un hilo se simula el envío de un correo a una dirección de correo aleatoria y en otro hilo se simula
                                la confirmación de la recepción de dicho email</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/ExampleWithOutRXJava?embed=true"></iframe>
                            <p>Ahora, el mismo ejemplo pero usando RxJava</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/RxJava?embed=true"></iframe>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_3">RxJS </h4>
                            <p>A continuación veremos un ejemplo simple de reactividad en <strong>Javascript</strong><br>
                                Iniciamos definiendo dos funciones:
                            <li>UpdateNotifications: Encargada de notificarnos cuando el usuario fue actualizado</li>
                            <li>GetUsers: La cual nos genera un usuario aleatorio</li>
                            En este primer ejemplo el usuario se creara sin problemas y seguido de esto será actualizado mediante el bucle <strong>for</strong>.
                            <script src="https://gist.github.com/BryGuz/0e86a967944f3b44d9403bb6156ab2a0.js"></script>
                            Ahora bien, ¿Qué ocurriría si en vez de un cliente tenemos un flujo de clientes continuo?
                            <strong>¡Correcto!</strong>, Al no terminar de crear clientes, el bucle for jamás llega a ejecutarse.
                            <script src="https://gist.github.com/BryGuz/aa37f4b361730ebc42819016a7b5023e.js"></script>
                            Una forma de solucionar este problema puede ser obligar la ejecución del programa mediante otra sentencia <strong>SetInterval</strong> y mejorandolo un poco, como vemos a continuación; ajustando el index desde el que se recorrera la lista de usuarios.<br>
                            Sin embargo está solución puede ser implementada utilizando programación reactiva de manera más elegante y <strong>¡Menos código!</strong>
                            <script src="https://gist.github.com/BryGuz/89c1511eb138b985af75b5a1af291ec9.js"></script>
                            Como observamos a continuación debemos declarar un <strong>Observador</strong> que será el encargado de avisarnos cuando se crea un nuevo usuario y comunicarlo al <strong>Suscribe</strong>, el cual se ejecutará apenas el estado de la lista cambie.
                            <script src="https://gist.github.com/BryGuz/01e86ca59de45213615fd219058de169.js"></script>
                            </p>





                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_4">RxRuby </h4>
                            <p>El siguiente ejemplo crea un observable que emite números secuenciales, uno cada 2 segundos, luego estos son capturados
                                por el suscriptor y ejecutada la función según el caso</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/RXRuby?embed=true"></iframe>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                    <div class="row">
                        <div class="col-md-12">
                            <h4 id="line8_5">Rx.NET </h4>
                            <p>El siguiente ejemplo crea 2 Observables, cada uno de un único elemento, luego los combina realizando la suma de los
                                valores y selecciona la respuesta como String en caso de que la suma sea par, esta combinación se muestra
                                tanto haciendo uso de sintaxis basada en Queries como en sintaxis fluida</p>
                            <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@Jaider_AndresAn/RxNET?embed=true"></iframe>

                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <hr>

                </section>
                <!-- end section -->

                <section id="line9" class="section">

                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Aplicaciones<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->

                    <div class="row">
                        <div class="col-md-6">

                            <strong>Dominios de Aplicación:</strong>
                            <p>Muchas empresas están utilizando esta forma de programación actuamente y con mucha razón. Como ya hemos señalado, permite crear aplicaciónes o sitios web de tal manera que ofrece una mejor experiencia de usuario. Resultados más suaves y rápidos provienen de este paradigma y hace que la interacción del usuario sea mucho mejor. Naturalmente, esto se traduce en clientes más felices y más ventas para el negocio.</p>

                            <p>Compañías como <strong>Netflix</strong> llevan años aplicando la programación reactiva para mejorar el rendimiento de sus aplicaciones, superando las limitaciones nativas de multiples lenguajes. Reactivex y otras librerias les proporcionó la pieza que necesitaban para realizar la orquestación de microservicios, la implementación del patrón <a href="https://martinfowler.com/bliki/CircuitBreaker.html"><strong>circuit breaker</strong></a> y demás mecanismos que permiten a sus desarrollos adoptar los principios descritos por el manifiesto reactivo.</p>

                            <p> <strong>Capital One</strong> rediseñó su aplicación de préstamos para automóviles en torno a los principios Reactivos para simplificar la compra y financiación de automóviles en línea. Los clientes pueden navegar por más de cuatro millones de automóviles de más de 12.000 concesionarios y precalificar el financiamiento en segundos, sin afectar las puntuaciones de crédito.</p>
                            <p> <strong>LinkedIn</strong> recurrió a los principios Reactivos para crear indicadores de presencia en tiempo real (indicadores en línea) para los medio billón de usuarios de su red social.</p>
                            <p> <strong>Verizon Wireless</strong>, operadores de la red 4G LTE más grande en Estados Unidos, redujo los tiempos de respuesta a la mitad utilizando los principios de Reactive en la actualización de su sitio web de comercio electrónico que soporta 146 millones de suscriptores que manejan 2.500 millones de transacciones al año.</p>
                            <p> <strong>Walmart Canada</strong> reconstruyó toda su aplicación web y pila móvil como un sistema Reactivo y vió un aumento del 20 por ciento en la conversión a ventas de tráfico web y un aumento del 98 por ciento en los pedidos móviles recortando los tiempos de carga de páginas en más de un tercio. </p>
                            <p>En <strong>Tenea</strong>, empresa que se dedica a implantar soluciones de negocio a través de las nuevas tecnologías, están trabajando hace más de 5 años con tecnologías como ActiveMQ, RabittMQ, Fuse Enterprise (componentes OSGI), mongoDB, ElasticSearch o Solr y, por supuesto, en orientación a eventos y en programación reactiva. Concretamente, en su motor de reglas IoT TeneaRules, que han miniaturizado para que corra sobre hardware de dominio público low cost (TP-Llink, Xiaomi), sobre el open source OpenWrt y cuya sintaxis declarativa y funcional les permite programar comportamientos asociados a los eventos del entorno: ES_DE(NOCHE)= , ALARMA(ON)= ; PUERTA,PRINCIPAL(ABIERTA)=, etc. </p>
                            <p><strong>Jafar Husain</strong>, Desarrollador Senior en el equipo de Interfaz de Usuario de TV en <strong> Netflix</strong> comenta lo siguiente:<br>
                                <cite>"Over the last year, Netflix has reinvented our client-server interaction model. One of the key building blocks of our platform is Microsoft’s open-source Reactive Extensions library (Rx). Netflix is a big believer in the Rx model, because Rx has made it much easier for us to build complex asynchronous programs."</cite>
                            </p>
                            <p>Husain Tambien menciona que actualmente Netflix es de las pocas compañias que que utiliza la programación reactiva tanto en el servidor como en el cliente, sin embargo no son la única: <strong> Felipe Lima</strong>, Miembro del equipos de desarrollo de Android en <strong>Airbnb</strong>, menciona el porque decidieron inclinarse hacia la programación reactiva mediante RxJava:<br> <cite >" It’s easy to switch back and forth between threads. It’s built right into the framework, Async can be very cumbersome and error-prone, and RxJava is one reason we you don’t need to do that anymore, and why you can compose different tasks together".</cite> </p>

                            <p>La programación reactiva se ha aplicado durante varios años en el <a href="http://reactivex.io/"><strong>Front-end</strong></a> Mediante el uso de cambios de estado en los diferentes componentes <a href="https://dev.to/petyosi/reactive-programming-for-react-developers-the-absolute-beginner-guide-5eeg">Reactive Programming for React Developers</a></p>
                            <center><a href="http://reactivex.io/" data-rel="frontend"><img src="images/frontend.PNG" alt="Frontend en Reactivex" class="img-responsive img-thumbnail"></a>
                                <figcaption>Uno de los principales usos de Recativex</figcaption>
                            </center>


                        </div>
                        <div class="col-md-6">
                            <strong>Algunas compañias que hacen uso de este Paradigma en sus productos:</strong>
                            <center><a href="http://reactivex.io/" data-rel="frontend"><img src="images/compañias.PNG" alt="Compañias que usan RecativeX" class="img-responsive img-thumbnail"></a>
                                <figcaption>Compañias como Netflix y Microsoft han apostado a este paradigma</figcaption>
                            </center>

                            <strong>Fase monolito y evolución en la industria</strong>

                            <p>Tras un periodo de desarrollo de software, la empresa dispondrá de una plataforma que crecerá hasta donde el éxito le acompañe, incrementando la complejidad del ya sofisticado entorno. Tanto si la plataforma es Java, C#, PHP, Python o Perl, el desarrollo corre el riesgo de convertirse en un monolito difícil de mantener y evolucionar. Los procesos inicialmente simples tienden a cubrir cada vez más variantes, en función de las necesidades definidas por Dirección, Marketing o el propio Product Owner.</p>

                            <p>En una situación como esta la solución más adoptada por los Arquitectos de Desarrollo es la de evolucionar hacia una arquitectura:</p>

                            <ul>
                                <li>    1.  Orientada a servicios. Cada servicio es una función sin estado que recibe una llamada y devuelve una respuesta.</li>

                                <li>    2.  Orientada a microservicios. Es una evolución de la orientación a servicios. Como en el caso anterior los microservicios están coordinados a través de la ORQUESTACIÓN.</li>

                                <li>    3.  Reactiva, funcional y orientada a microservicios pero coordinados por COREOGRAFIA, y con la inferencia basada en eventos de negocio.</li>
                            </ul>

                            <strong>Arquitectura Reactiva Funcional</strong>

                            <p>La arquitectura reactiva funcional es aquella en la que la inferencia son los EVENTOS. En este caso no hablamos de eventos de sistema, como los subsistemas de ventanas de los entornos gráficos (X11, Windows o Gnome), sino por eventos de negocio.</p>
                            <p>La reactividad ha aparecido no solo en la parte servidora: Spring, Vert.x, ya que afecta a la arquitectura de ejecución sino que ha entrado para instalarse de forma definitiva en la parte cliente con implementaciones en Javascript: Reactjsliberada por Facebook al mundo open, Bacon.js o RxJS.</p>
                            <p>La importancia para las empresas radica en que se puede crear funcionalidad a partir de cualquier evento que se genere: alta_cliente, baja_cliente, venta_producto, así como la gestión de las operaciones: rotura_stock, paquetes_fuera_stock_minimo, alta_empleado, fin_promocion, envio_urgente, etc.</p>
                            <p>Esto permitirá interceptar el flujo de datos, crear bases de datos/registros y/o funcionalidades que multiplican las capacidades digitales de la empresa, creando una nueva especie de empresas más flexibles, más adaptadas a los nuevos escenarios y, por tanto, más competitivas.</p>

                            <p>La solución, que ya documentan empresas como <strong>Nginx</strong> y otros fabricantes, es evolucionar de aplicaciones MONOLITO a micro servicios reactivos y funcionales con un roadmap bien definido, que acople el día a día de la empresa con la introducción de la arquitectura reactiva que ya usan empresas como <strong>Netflix</strong> u otras muchas.</p>

                            <p>En definitiva, ya estamos en el momento de marcar el rumbo hacia estas nuevas herramientas y entornos de desarrollo.</p>

                        </div>
                    </div>
                    <!-- end row -->
                </section>
                <!-- end section -->
                <section id="line10" class="section">
                    <div class="row">
                        <div class="col-md-12 left-align">
                            <h2 class="dark-text">Referencias<hr></h2>
                        </div>
                        <!-- end col -->
                    </div>
                    <!-- end row -->
                    <div class="row">
                        <div class="col-md-12">





                            <ul>
                                <li>1. <a href="http://reactivex.io/languages.html">ReactiveX</a></li>
                                <li>2. <a href="https://colab.research.google.com/drive/19SeUjUM_AYaxhGB-qintY822lC9NO1La?usp=sharing">Codigo RxPY</a> </li>
                                <li>3. <a href="https://www.tutorialspoint.com/rxpy/rxpy_quick_guide.htm">Mas Ejemplos RxPy</a></li>
                                <li>4. <a href="https://www.baeldung.com/rx-java">RxJava</a></li>
                                <li>5. <a href="https://www.toptal.com/android/functional-reactive-android-rxjava">RxJava Android</a></li>
                                <li>6. <a href="https://www.amazon.com/-/es/Luca-Mezzalira-ebook/dp/B077GCMHNS">Front-End Reactive Architectures de Luca Mezzalira</a></li>
                                <li>7. <a href="https://go.lightbend.com/reactive-microservices-architecture-design-principles-for-distributed-systems-oreilly">Reactive Microservices Architecture de Jonas Bonér</a></li>
                                <li>8. <a href="https://www.amazon.es/Reactive-Systems-Architecture-Jan-Machacek/dp/1491980710">Reactive Systems Architecture de Jan Machacek, Martin Zapletal, Michal Janousek , Anirvan Chakraborty</a></li>
                                <li>9. <a href="https://podcasts.apple.com/tt/podcast/reactive-architecture-patterns-debate/id1487784619?i=1000460072673&l=fr">GSAS: Reactive Architecture Patterns Debate</a></li>
                                <li>10. <a href="https://www.youtube.com/watch?v=OPhQvG1-32k">What is a Reactive Application? • Panel Debate</a></li>
                                <li>11. <a href="https://www.youtube.com/watch?v=RuHkNGrwD5o">Reactive Systems: 21st Architecture for 21st Century Systems by Dave Farley</a></li>
                                <li>12. <a href="https://refactoring.guru/es/design-patterns/observer">Patrón Observer</a></li>
                                <li>13. <a href="https://profile.es/blog/que-es-la-programacion-reactiva-una-introduccion/#:~:text=La%20programaci%C3%B3n%20reactiva%20es%20un,o%20infinitos%20de%20manera%20as%C3%ADncrona.&text=Orientados%20a%20mensajes%3A%20minimizan%20el,de%20mensajes%20de%20manera%20as%C3%ADncrona">¿Qué es la programación reactiva? Una introducción</a></li>
                                <li>14. <a href="https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems">Reactive Programming versus Reactive Systems | White Paper | Lightbend</a></li>
                                <li>15. <a href="https://developer.ibm.com/articles/defining-the-term-reactive/">Defining the term 'reactive'</a></li>
                                <li>16. <a href="https://dzone.com/articles/what-are-reactive-streams-in-java">What Are Reactive Streams in Java?</a></li>
                                <li>17. <a href="https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape">Notes on Reactive Programming</a></li>
                                <li>18. <a href="https://akarnokd.blogspot.com/2016/03/operator-fusion-part-1.html">Generations of reactive classification</a></li>
                                <li>19. <a href="https://itnext.io/demystifying-functional-reactive-programming-67767dbe520b">Demystifying Functional Reactive Programming</a></li>
                            </ul>

                        </div>
                    </div>
                    <!-- end row -->
                </section>
                <!-- end section -->

                <!-- end section -->
            </div>
            <!-- // end .col -->
        </div>
        <!-- // end .row -->
    </div>
    <!-- // end container -->
</div>
<!-- end wrapper -->
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/retina.js"></script>
<script src="js/jquery.fitvids.js"></script>
<script src="js/wow.js"></script>
<script src="js/jquery.prettyPhoto.js"></script>
<!-- CUSTOM PLUGINS -->
<script src="js/custom.js"></script>
<script src="js/main.js"></script>
<script src="js/syntax-highlighter/scripts/shCore.js"></script>
<script src="js/syntax-highlighter/scripts/shBrushXml.js"></script>
<script src="js/syntax-highlighter/scripts/shBrushCss.js"></script>
<script src="js/syntax-highlighter/scripts/shBrushJScript.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.1/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>